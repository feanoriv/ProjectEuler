from my_tools.tools import timer, factorial

"""
Задача 24
Перестановка - это упорядоченная выборка объектов. К примеру, 
3124 является одной из возможных перестановок из цифр 1, 2, 3 и 4. 
Если все перестановки приведены в порядке возрастания или алфавитном порядке, 
то такой порядок будем называть словарным. Словарные перестановки из цифр 0, 1 и 2 представлены ниже:
012   021   102   120   201   210
Какова миллионная словарная перестановка из цифр 0, 1, 2, 3, 4, 5, 6, 7, 8 и 9?
"""


# Всего перестановок n! для n символов.
# Для bruteforce идеально подходит permutations() из itertools.
# Но есть способ гораздо быстрее. Пример ниже:

# Допустим нужно определить сотую перестановку для n=5 (0,1,2,3,4)
# Первый символ определяется как номер одного из 5 диапазонов:
# 0(1-24) 1(25-48) 2(49-72) 3(73-96) 4(97-120) # Первый символ = 4

# Второй символ определяется как номер одного из 4 диапазонов:
# 0(97-102) 1(103-108) 2(109-114) 3(115-120) # Второй символ = 0

# Третий символ определяется как номер одного из 3 диапазонов:
# 1(97-98) 2(99-100) 3(101-102) # Третий символ = 2

# Четвертый символ определяется как номер одного из 2 диапазонов:
# 1(99) 3(100) # Четвертый символ = 3
# И последний символ = 1
# Результат для n=5, № перестановки=100 - 40231

# from itertools import permutations
# a = permutations([0, 1, 2, 3, 4])
# for i, per in enumerate(a):
#     print(i+1, per)


@timer
def problem_24(n: int = 10, number: int = 1000000):
    start = list(range(n))
    res = []
    for i in range(n):
        lst = []
        step = factorial(n - 1 - i)
        for k in range(1, n + 1 - i):
            lst.append(k * step)
        for ind, arr in enumerate(lst):
            if arr >= number:
                if ind != 0:
                    number = number - lst[ind - 1]
                res.append(start[lst.index(arr)])
                start.pop(lst.index(arr))
                break

    return "".join([str(x) for x in res])


if __name__ == "__main__":
    print(problem_24())
