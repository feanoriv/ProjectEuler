"""
Задача 21
Пусть d(n) определяется как сумма делителей n (числа меньше n, делящие n нацело).
Если d(a) = b и d(b) = a, где a ≠ b, то a и b называются дружественной парой, 
а каждое из чисел a и b - дружественным числом.
Например, делителями числа 220 являются 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 и 110, 
поэтому d(220) = 284. Делители 284 - 1, 2, 4, 71, 142, поэтому d(284) = 220.
Подсчитайте сумму всех дружественных чисел меньше 10000.
"""


def divisors(n):
    res = [1]
    if n <= 1:
        return [0]
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0 and i ** 2 != n:
            res.append(i)
            res.append(int(n / i))
        elif i ** 2 == n:
            res.append(i)
    return res


@timer
def problem_21(n=10000):
    res = []
    for i in range(1, n + 1):
        a_num = sum(divisors(i))
        if i != a_num:
            if i == sum(divisors(a_num)):
                res.append(i)
    return res


# print(sum(problem_21()))

"""
Задача 22
Используйте names.txt (щелкнуть правой кнопкой мыши и выбрать 'Save Link/Target As...'),
текстовый файл размером 46 КБ, содержащий более пяти тысяч имен. Начните с сортировки 
в алфавитном порядке. Затем подсчитайте алфавитные значения каждого имени и умножьте 
это значение на порядковый номер имени в отсортированном списке для получения количества 
очков имени.
Например, если список отсортирован по алфавиту, имя COLIN (алфавитное значение которого 
3 + 15 + 12 + 9 + 14 = 53) является 938-м в списке. Поэтому, имя COLIN получает 938 × 53 = 49714 
очков.
Какова сумма очков имен в файле?
"""


def read_file_return_lst(file="files/names.txt"):
    with open(file) as file:
        text = file.read()
    text = text.replace('"', '').lower()
    text = text.split(",")
    return sorted(text)


char2 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
         'w', 'x', 'y', 'z']


@timer
def problem_22():
    names = read_file_return_lst()
    lst_points = []
    for ind, name in enumerate(names):
        points = 0
        for char in name:
            points += char2.index(char) + 1
        points *= (ind + 1)
        lst_points.append(points)
    return sum(lst_points)


# print(problem_22())


"""
Задача 23
Совершенным числом называется число, у которого сумма его делителей равна самому числу. 
Например, сумма делителей числа 28 равна 1 + 2 + 4 + 7 + 14 = 28, что означает, что число 
28 является совершенным числом.
Число n называется недостаточным, если сумма его делителей меньше n, и называется избыточным, 
если сумма его делителей больше n.
Так как число 12 является наименьшим избыточным числом (1 + 2 + 3 + 4 + 6 = 16), наименьшее 
число, которое может быть записано как сумма двух избыточных чисел, равно 24. Используя 
математический анализ, можно показать, что все целые числа больше 28123 могут быть записаны 
как сумма двух избыточных чисел. Эта граница не может быть уменьшена дальнейшим анализом, 
даже несмотря на то, что наибольшее число, которое не может быть записано как сумма двух 
избыточных чисел, меньше этой границы.
Найдите сумму всех положительных чисел, которые не могут быть записаны как сумма двух 
избыточных чисел.
"""


def set_abundant_numbers(n=28123) -> list:
    res = set()
    for i in range(n):
        if sum(divisors(i)) > i:
            res.add(i)
    return res


@timer
def problem_23(n=28123):
    set_amb = set_abundant_numbers()
    lst_2_amb = list(range(1, n))
    for i in range(24, n):
        for num1 in set_amb:
            if i - num1 < 0:
                break
            if i - num1 in set_amb:
                lst_2_amb.remove(i)
                break
    return sum(lst_2_amb)


""" 
---Комментарий к решению---
В течении половины дня я размышлял над тем как оптимизировать код!
Читал статьи в Вики о совершенных, избыточных и недостаточных числах.
Код работал 370 секунд, а значит существовал алгоритм, но найти я его так и не смог=(
Оставил как есть и пошёл проверять ответ, заодно глянуть что за хитрые алгоритмы мне не дались...
А нет никакого алгоритма! Чтобы код работал в 150 раз быстрее нужно было изменить list() на set()!
Впервые вижу чтобы уместно применённый тип данных так зарешал.
В своём коде изменил list на set, т.к. считаю, что задачка покорилась ибо алгоритм я не менял.
"""
# print(problem_23())


"""
ЗАдача 24
Перестановка - это упорядоченная выборка объектов. К примеру, 
3124 является одной из возможных перестановок из цифр 1, 2, 3 и 4. 
Если все перестановки приведены в порядке возрастания или алфавитном порядке, 
то такой порядок будем называть словарным. Словарные перестановки из цифр 0, 1 и 2 представлены ниже:
012   021   102   120   201   210
Какова миллионная словарная перестановка из цифр 0, 1, 2, 3, 4, 5, 6, 7, 8 и 9?
"""


def factorial(n: int) -> int:
    res = 1
    for i in range(1, n + 1):
        res *= i
    return res


@timer
def problem_24(n: int, number: int = 1000000) -> list:
    start = list(range(n))
    res = []
    for i in range(n):
        lst = []
        step = factorial(n - 1 - i)
        for k in range(1, n + 1 - i):
            lst.append(k * step)
        for ind, arr in enumerate(lst):
            if arr >= number:
                if lst[ind] != 0:
                    number = number - lst[ind - 1]
                res.append(start[lst.index(arr)])
                start.pop(lst.index(arr))
                break

    return "".join([str(x) for x in res])


""" 
---Комментарий---
Сделал вот такой интересный алгоритм со сложностью On где n - кол-во цифр,
Проверяя ответ обнаружил, что ребята использовали готовый модуль "from itertools import permutations"
и брутфорсят ответ. Их алгоритм с использованием permutations - 1187 ms, а мой - 0 ms=))))
Опять рад)
"""
# print(problem_24(n=10, number=1000000))


"""
Задача 25
Последовательность Фибоначчи определяется рекурсивным правилом:
Fn = Fn−1 + Fn−2, где F1 = 1 и F2 = 1.
Таким образом, первые 12 членов последовательности равны:
F1 = 1
F2 = 1
F3 = 2
F4 = 3
F5 = 5
F6 = 8
F7 = 13
F8 = 21
F9 = 34
F10 = 55
F11 = 89
F12 = 144
Двенадцатый член F12 - первый член последовательности, который содержит три цифры.
Каков порядковый номер первого члена последовательности Фибоначчи, содержащего 1000 цифр?
"""


def problem_25(n=1000) -> int:
    res = 2
    a1, a2 = 1, 1
    while True:
        a1, a2 = a2, a1 + a2
        res += 1
        if len(str(a2)) >= n:
            return res


# print(problem_25())

"""
Задача 26
Единичная дробь имеет 1 в числителе. Десятичные представления единичных дробей 
со знаменателями от 2 до 10 даны ниже:
1/2	=	0.5
1/3	=	0.(3)
1/4	=	0.25
1/5	=	0.2
1/6	=	0.1(6)
1/7	=	0.(142857)
1/8	=	0.125
1/9	=	0.(1)
1/10	=	0.1
Где 0.1(6) значит 0.166666..., и имеет повторяющуюся последовательность из одной цифры. 
Заметим, что 1/7 имеет повторяющуюся последовательность из 6 цифр.
Найдите значение d < 1000, для которого 1/d в десятичном виде содержит самую 
длинную повторяющуюся последовательность цифр.
"""


@timer
def problem_26(n=1000, length=3000):
    res = [0, [1]]
    for i in range(1, n + 1):
        base = 1
        lst = []
        for k in range(length):
            if base < i and base != 0:
                base *= 10
                if base < i and base != 0:
                    base *= 10
                    lst.append(0)
                    if base > i:
                        continue
                    if base < i and base != 0:
                        base *= 10
                        lst.append(0)
                        if base > i:
                            continue
                        if base < i:
                            base *= 10
                            lst.append(0)
                            if base > i:
                                continue
            if base == 0:
                lst.append(0)
            if base >= i:
                x = base // i
                base = base % i
                lst.append(x)

        flag = True
        seq = lst[::-1]
        for j in range(int(length / 3), 1, -1):
            if seq[0:j] == seq[j:j * 2] and seq[0 + 1:j + 1] != seq[0:j]:
                seq = seq[0:j]
                for k in range(1, j):
                    if seq[0:k] == seq[k:2 * k]:
                        if flag:
                            seq = seq[0:k]
                            if len(seq) > len(res[1]):
                                res[0], res[1] = i, seq
                            flag = False
                            break
                if flag:
                    if len(seq) > len(res[1]):
                        res[0], res[1] = i, seq
                        break

    return res[0], len(res[1])


""" Ответ - верный, подход - не очень"""
# print(problem_26())

"""
Задача 27
Эйлер опубликовал свою замечательную квадратичную формулу:
n^2+n+41
Оказалось, что согласно данной формуле можно получить 40 простых чисел, последовательно подставляя 
значения 0≤n≤39. Однако, при n=40, 402+40+41=40(40+1)+41 делится на 41 без остатка, и, очевидно, при 
n=41,412+41+41 делится на 41 без остатка.
При помощи компьютеров была найдена невероятная формула n2−79n+1601, согласно которой можно получить 
80 простых чисел для последовательных значений n от 0 до 79. Произведение коэффициентов −79 и 1601 равно −126479.
Рассмотрим квадратичную формулу вида:
n^2+an+b, где |a|<1000 и |b|≤1000
где |n| является модулем (абсолютным значением) n.
К примеру, |11|=11 и |−4|=4
Найдите произведение коэффициентов a и b квадратичного выражения, согласно которому можно получить 
максимальное количество простых чисел для последовательных значений n, начиная со значения n=0.
"""


@timer
def problem_27(a_max=999, b_max=1000):
    res = [0, []]
    for b in range(b_max + 1):
        flag = True
        if is_prime(abs(b)):
            for a in range(-a_max, a_max + 1):
                if flag:
                    for n in range(100):
                        x = n ** 2 + a * n + b
                        if is_prime(abs(x)):
                            continue
                        else:
                            if res[0] < n:
                                res = [n, [a, b]]

                            break
    return res[1][0] * res[1][1]


# print(problem_27())

"""
Задача 28
Начиная с числа 1 и двигаясь дальше вправо по часовой стрелке, образуется следующая спираль 5 на 5:
21 22 23 24 25
20  7  8  9 10
19  6  1  2 11
18  5  4  3 12
17 16 15 14 13
Можно убедиться, что сумма чисел в диагоналях равна 101.
Какова сумма чисел в диагоналях спирали 1001 на 1001, образованной таким же способом?
"""


@timer
def problem_28(n=1001):
    res = 1
    for i in range(3, n + 1, 2):
        res += i ** 2 + (i ** 2 - (i - 1) * 1) + (i ** 2 - (i - 1) * 2) + (i ** 2 - (i - 1) * 3)

    return res


# print(problem_28())


"""
Задача 29
Рассмотрим все целочисленные комбинации ab для 2 ≤ a ≤ 5 и 2 ≤ b ≤ 5:
2^2=4, 2^3=8, 2^4=16, 2^5=32
3^2=9, 3^3=27, 3^4=81, 3^5=243
4^2=16, 4^3=64, 4^4=256, 4^5=1024
5^2=25, 5^3=125, 5^4=625, 5^5=3125
Если их расположить в порядке возрастания, исключив повторения, мы получим
 следующую последовательность из 15 различных членов:
4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
Сколько различных членов имеет последовательность ab для 2 ≤ a ≤ 100 и 2 ≤ b ≤ 100?
"""


@timer
def problem_29(a=100, b=100):
    res = set()
    for i in range(2, a + 1):
        for j in range(2, b + 1):
            res.add(i ** j)
    return len(res)


# print(problem_29())


"""
Задача 30
Удивительно, но существует только три числа, которые могут быть 
записаны в виде суммы четвертых степеней их цифр:
1634 = 14 + 64 + 34 + 44
8208 = 84 + 24 + 04 + 84
9474 = 94 + 44 + 74 + 44
1 = 14 не считается, так как это - не сумма.
Сумма этих чисел равна 1634 + 8208 + 9474 = 19316.
Найдите сумму всех чисел, которые могут быть записаны в виде суммы пятых степеней их цифр.
"""


@timer
def problem_30(power=5):
    res = []

    def max_len(power=power):
        n = 2
        while True:
            if len(str(n * (9 ** power))) < n:
                return n - 1
            else:
                n += 1

    for i in range(2, int("9" * max_len(power))):
        lst = [int(n) ** power for n in list(str(i))]
        if sum(lst) == i:
            res.append(i)

    return sum(res)


# print(problem_30())

"""
Задача 31
В Англии валютой являются фунты стерлингов £ и пенсы p, и в обращении есть восемь монет:
1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) и £2 (200p).
£2 возможно составить следующим образом:
1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p
Сколькими разными способами можно составить £2, используя любое количество монет?
"""


@timer
def problem_31(n=200):
    coins = [2, 5, 10, 20, 50, 100, 200]
    indexes = [-2, -3, -4, -5, -7, -8, -9]
    res = [[]]
    while sum(res[0]) < n:
        print(sum(res[0]))
        for lst in res:
            lst.append(1)
        new_lists = []
        for lst in res:
            for ind in indexes:
                if sum(lst[ind:]) == coins[indexes.index(ind)]:
                    new_lst = lst[:]
                    del new_lst[ind:]
                    new_lst.insert(ind, coins[indexes.index(ind)])
                    new_lists.append(sorted(new_lst, reverse=True))

        if new_lists:
            for lst in new_lists:
                if lst not in res:
                    res.append(lst)

    return len(res)


""" Решается около 10 минут, надо оптимизировать"""
# print(problem_31())


"""
Задача 32
Каждое n-значное число, которое содержит каждую цифру от 1 до n ровно один раз, будем считать 
пан-цифровым; к примеру, 5-значное число 15234 является пан-цифровым, т.к. содержит цифры от 1 до 5.
Произведение 7254 является необычным, поскольку равенство 39 × 186 = 7254, состоящее из множимого, 
множителя и произведения является пан-цифровым, т.е. содержит цифры от 1 до 9.
Найдите сумму всех пан-цифровых произведений, для которых равенство "множимое × множитель = произведение" 
можно записать цифрами от 1 до 9, используя каждую цифру только один раз.
ПОДСКАЗКА: Некоторые произведения можно получить несколькими способами, поэтому убедитесь, что включили 
их в сумму лишь единожды.
"""


@timer
def problem_32():
    res = set()
    for i in range(3000):
        for j in range(99):
            text_num = str(i * j) + str(j) + str(i)
            if len(text_num) == 9:
                if "0" not in text_num:
                    if len(set(list(text_num))) == 9:
                        print(i, j, i * j)
                        res.add(i * j)

    return sum(res)


# print(problem_32())


"""
Задача 33
Дробь 49/98 является любопытной, поскольку неопытный математик, пытаясь сократить ее, 
будет ошибочно полагать, что 49/98 = 4/8, являющееся истиной, получено вычеркиванием девяток.
Дроби вида 30/50 = 3/5 будем считать тривиальными примерами.
Существует ровно 4 нетривиальных примера дробей подобного типа, которые меньше единицы и содержат 
двухзначные числа как в числителе, так и в знаменателе.
Пусть произведение этих четырех дробей дано в виде несократимой дроби (числитель и знаменатель дроби 
не имеют общих сомножителей). Найдите знаменатель этой дроби.
"""


@timer
def problem_33():
    numbers = []
    for i in range(11, 99):
        for k in range(11, 99):
            if i < k:
                res = i / k
                x, y = str(i), str(k)
                if "0" not in x + y:
                    if ((int(x[0]) / int(y[0]) == res) and (int(x[1]) == int(y[1]))) or \
                            ((int(x[1]) / int(y[0]) == res) and (int(x[0]) == int(y[1]))) or \
                            ((int(x[0]) / int(y[1]) == res) and (int(x[1]) == int(y[0]))) or \
                            ((int(x[1]) / int(y[1]) == res) and (int(x[0]) == int(y[0]))):
                        numbers.append([i, k])
    num1, num2 = 1, 1
    for i in numbers:
        num1 *= i[0]
        num2 *= i[1]
    for i in divisors(num2)[::-1]:
        if (num1 % i == 0) and (num2 % i == 0):
            num1 = num1 / i
            num2 = num2 / i

    return num2


# print(problem_33())


"""
Задача 34
145 является любопытным числом, поскольку 1! + 4! + 5! = 1 + 24 + 120 = 145.
Найдите сумму всех чисел, каждое из которых равно сумме факториалов своих цифр.
Примечание: поскольку 1! = 1 и 2! = 2 не являются суммами, учитывать их не следует.
"""


@timer
def problem_34():
    res = 0
    # TODO почему такой лимит? Зная ответ можно вписать 41000 и решение будет за 0,5 с., а с этим лимитом 16 с.
    limit = 7 * factorial(9) + 1
    for i in range(3, limit):
        sum_factorials = sum([factorial(int(i)) for i in list(str(i))])
        if sum_factorials == i:
            print(i)
            res += i
    return res


# print(problem_34())


"""
Задача 25
Число 197 называется круговым простым числом, потому что все перестановки его цифр 
с конца в начало являются простыми числами: 197, 719 и 971.
Существует тринадцать таких простых чисел меньше 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79 и 97.
Сколько существует круговых простых чисел меньше миллиона?
"""


def check_variations_is_prime(n: str):
    if len(n) == 1:
        return True
    if any(num in ["0", "2", "4", "6", "8"] for num in n):
        return False
    for i in range(len(n)):
        n = n[1:] + n[0]
        if not is_prime(int(n)):
            return False
    return True


@timer
def problem_35(n=1000000):
    res = 0
    for i in range(2, n):
        if is_prime(i):
            if check_variations_is_prime(str(i)):
                res += 1
    return res


# print(problem_35())


"""
Задача 36
Десятичное число 585 = 10010010012 (в двоичной системе), является палиндромом по обоим основаниям.
Найдите сумму всех чисел меньше миллиона, являющихся палиндромами по основаниям 10 и 2.
(Пожалуйста, обратите внимание на то, что палиндромы не могут начинаться с нуля ни в одном из оснований).
"""


def is_palindrome(n: str):
    if n == n[::-1]:
        return True


@timer
def problem_36(n=1000000):
    res = 0
    for i in range(1, n, 2):
        if all([is_palindrome(str(i)), is_palindrome(bin(i)[2:])]):
            res += i

    return res


# print(problem_36())


"""
Задача 37
Число 3797 обладает интересным свойством. Будучи само по себе простым числом, 
из него можно последовательно выбрасывать цифры слева направо, число же при этом 
остается простым на каждом этапе: 3797, 797, 97, 7. Точно таким же способом можно 
выбрасывать цифры справа налево: 3797, 379, 37, 3.
Найдите сумму единственных одиннадцати простых чисел, из которых можно выбрасывать 
цифры как справа налево, так и слева направо, но числа при этом остаются простыми.
ПРИМЕЧАНИЕ: числа 2, 3, 5 и 7 таковыми не считаются.
"""


def check_variations_is_prime_2(n: str):
    if len(n) == 1:
        return False
    if n.endswith("1") or n.startswith("1"):
        return False
    if any(num in ["0", "4", "6", "8"] for num in n):
        return False
    for i in range(len(n) - 1):
        n1 = n[i + 1:]
        n2 = n[:-i - 1]
        if not is_prime(int(n1)):
            return False
        if not is_prime(int(n2)):
            return False
    return True


@timer
def problem_37(n=1000000):
    res = 0
    for i in range(11, n, 2):
        if is_prime(i):
            if check_variations_is_prime_2(str(i)):
                res += i
    return res


# print(problem_37())


"""
Задача 38
Возьмем число 192 и умножим его по очереди на 1, 2 и 3:
192 × 1 = 192
192 × 2 = 384
192 × 3 = 576
Объединяя все три произведения, получим девятизначное число 192384576 из цифр 
от 1 до 9 (пан-цифровое число). Будем называть число 192384576 объединенным произведением 192 и (1,2,3)
Таким же образом можно начать с числа 9 и по очереди умножать его на 1, 2, 3, 4 и 5, 
что в итоге дает пан-цифровое число 918273645, являющееся объединенным произведением 9 и (1,2,3,4,5).
Какое самое большое девятизначное пан-цифровое число можно образовать как объединенное 
произведение целого числа и (1,2, ... , n), где n > 1?
"""


@timer
def problem_38():
    res = []
    for i in range(10000):
        text_num = ""
        for k in range(1, 10):
            text_num += str(k * i)
            if len(text_num) == 9:
                if "0" not in text_num:
                    if len(set(list(text_num))) == 9:
                        res.append(int(text_num))
                else:
                    break
    return max(res)


# print(problem_38())


"""
Задача 39
Если p - периметр прямоугольного треугольника с целочисленными длинами 
сторон {a,b,c}, то существует ровно три решения для p = 120:
{20,48,52}, {24,45,51}, {30,40,50}
Какое значение p ≤ 1000 дает максимальное число решений?
"""


@timer
def problem_39(n=1000):
    res = []
    for a in range(1, n):
        for b in range(1, n):
            c = (a ** 2 + b ** 2) ** 0.5
            if c % 1 == 0:
                res.append(a + b + c)
    max_count = [0, 0]
    for i in res:
        if i <= n:
            count = res.count(i)
            if count > max_count[0]:
                max_count[0] = count
                max_count[1] = i

    return max_count


# print(problem_39())

"""
Задача 40
Дана иррациональная десятичная дробь, образованная объединением натуральных чисел:
0.123456789101112131415161718192021...
Видно, что 12-я цифра дробной части - 1.
Также дано, что dn представляет собой n-ю цифру дробной части. Найдите значение следующего выражения:
d1 × d10 × d100 × d1000 × d10000 × d100000 × d1000000
"""


@timer
def problem_40():
    a = ""
    for i in range(400000):  # Можно до 1е6, но так чуть быстрее.
        a += str(i)
    return (int(a[1]) * int(a[10]) * int(a[100]) * int(a[1000])
            * int(a[10000]) * int(a[100000]) * int(a[1000000]))


# print(problem_40())


"""
Задача 41
Будем считать n-значное число пан-цифровым, если каждая из цифр от 1 
до nиспользуется в нем ровно один раз. К примеру, 2143 является 4-значным 
пан-цифровым числом, а также простым числом.
Какое существует наибольшее n-значное пан-цифровое простое число?
"""


@timer
def problem_41(n=7):
    for i in range(7777777, 1234567, -1):
        if i % 2 != 0:
            str_num = str(i)
            if ("0" not in str_num) and ("9" not in str_num) and ("8" not in str_num):
                if len(set(list(str_num))) == n:
                    if is_prime(i):
                        return i


""" Все пан-цифровые числа делятся на 3 кроме n=7,4,1. Поэтому проверяем 7 циферные."""

# print(problem_41())


"""
Задача 42
n-й член последовательности треугольных чисел задается как tn = ½n(n+1). 
Таким образом, первые десять треугольных чисел:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
Преобразовывая каждую букву в число, соответствующее ее порядковому номеру в 
алфавите, и складывая эти значения, мы получим числовое значение слова. 
Для примера, числовое значение слова SKY равно 19 + 11 + 25 = 55 = t10. 
Если числовое значение слова является треугольным числом, то мы назовем это слово треугольным словом.
Используя words.txt (щелкнуть правой кнопкой мыши и выбрать 
'Save Link/Target As...'), 16 КБ текстовый файл, содержащий около двух тысяч 
часто используемых английских слов, определите, сколько в нем треугольных слов.
"""


def get_num_char(x: str) -> int:
    if len(x) == 1:
        return ord(x) - 64
    else:
        raise ValueError("Передано больше одного символа")


def get_list_names_from_file(file: str) -> list:
    with open(file) as file:
        text = file.read().replace('"', "").split(",")
    return text


@timer
def problem_42():
    triangle_numbers = [int((n * (n + 1)) / 2) for n in list(range(1, 100))]
    words = get_list_names_from_file("files/p042_words.txt")
    res = 0
    for word in words:
        sum_chars = 0
        for char in word:
            sum_chars += get_num_char(char)
        if sum_chars in triangle_numbers:
            res += 1
    return res


# print(problem_42())


"""
Задача 43
Число 1406357289, является пан-цифровым, поскольку оно состоит из цифр от 0 до 9 
в определенном порядке. Помимо этого, оно также обладает интересным свойством делимости подстрок.
Пусть d1 будет 1-й цифрой, d2 будет 2-й цифрой, и т.д. В таком случае, можно заметить следующее:
d2d3d4=406 делится на 2 без остатка
d3d4d5=063 делится на 3 без остатка
d4d5d6=635 делится на 5 без остатка
d5d6d7=357 делится на 7 без остатка
d6d7d8=572 делится на 11 без остатка
d7d8d9=728 делится на 13 без остатка
d8d9d10=289 делится на 17 без остатка
Найдите сумму всех пан-цифровых чисел из цифр от 0 до 9, обладающих данным свойством.
"""


# Зачем изобретать велосипед?
def permutations(iterable, r=None):
    # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC
    # permutations(range(3)) --> 012 021 102 120 201 210
    pool = tuple(iterable)
    n = len(pool)
    r = n if r is None else r
    if r > n:
        return
    indices = list(range(n))
    cycles = list(range(n, n - r, -1))
    yield tuple(pool[i] for i in indices[:r])
    while n:
        for i in reversed(range(r)):
            cycles[i] -= 1
            if cycles[i] == 0:
                indices[i:] = indices[i + 1:] + indices[i:i + 1]
                cycles[i] = n - i
            else:
                j = cycles[i]
                indices[i], indices[-j] = indices[-j], indices[i]
                yield tuple(pool[i] for i in indices[:r])
                break
        else:
            return


@timer
def problem_43():
    res = 0
    n = permutations("9876543210")
    for i in n:
        if int(i[3]) % 2 != 0:
            continue
        if int(i[2] + i[3] + i[4]) % 3 != 0:
            continue
        j = "".join(i)
        if int(j[1] + j[2] + j[3]) % 2 == 0 and \
                int(j[2] + j[3] + j[4]) % 3 == 0 and \
                int(j[3] + j[4] + j[5]) % 5 == 0 and \
                int(j[4] + j[5] + j[6]) % 7 == 0 and \
                int(j[5] + j[6] + j[7]) % 11 == 0 and \
                int(j[6] + j[7] + j[8]) % 13 == 0 and \
                int(j[7] + j[8] + j[9]) % 17 == 0:
            res += int(j)
            print(j)
    return res


# print(problem_43())


"""
Задача 44
Пятиугольные числа вычисляются по формуле: Pn=n(3n−1)/2. 
Первые десять пятиугольных чисел:
1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
Можно убедиться в том, что P4 + P7 = 22 + 70 = 92 = P8. 
Однако, их разность, 70 − 22 = 48, не является пятиугольным числом.
Найдите пару пятиугольных чисел Pj и Pk, для которых сумма и разность 
являются пятиугольными числами и значение D = |Pk − Pj| минимально, и дайте значение D в качестве ответа.
"""


@timer
def problem_44():
    res = 999999999
    lst = set([int(n * (3 * n - 1) / 2) for n in range(1, 5000)])
    per_lst = permutations(lst, r=2)
    for i in per_lst:
        if (i[0] + i[1]) in lst and abs(i[0] - i[1]) in lst:
            d = abs(i[0] - i[1])
            if d < res:
                res = d
    return res


# print(problem_44())


"""
Задача 45
Треугольные, пятиугольные и шестиугольные числа вычисляются по нижеследующим формулам:
Треугольные	 	    Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Пятиугольные	 	Pn=n(3n−1)/2	1, 5, 12, 22, 35, ...
Шестиугольные	 	Hn=n(2n−1)	 	1, 6, 15, 28, 45, ...
Можно убедиться в том, что T285 = P165 = H143 = 40755.
Найдите следующее треугольное число, являющееся также пятиугольным и шестиугольным.
"""


@timer
def problem_45():
    triangle_nums = set([n * (n + 1) / 2 for n in range(2, 100000)])
    fivangle_nums = set([n * (3 * n - 1) / 2 for n in range(2, 100000)])
    sixangle_nums = set([n * (2 * n - 1) for n in range(2, 100000)])
    for i in triangle_nums:
        if i in fivangle_nums and i in sixangle_nums:
            res = i
    return res


# print(problem_45())


"""
Задача 46
Кристиан Гольдбах показал, что любое нечетное составное число можно 
записать в виде суммы простого числа и удвоенного квадрата.
9 = 7 + 2×1^2
15 = 7 + 2×2^2
21 = 3 + 2×3^2
25 = 7 + 2×3^2
27 = 19 + 2×2^2
33 = 31 + 2×1^2
Оказалось, что данная гипотеза неверна.
Каково наименьшее нечетное составное число, которое нельзя записать в виде суммы 
простого числа и удвоенного квадрата?
"""


@timer
def problem_46(n=10000):
    res = set()
    nums = set([n for n in range(2, n) if not (is_prime(n)) and (n % 2 != 0)])
    prime_numbers = set([n for n in range(2, n) if is_prime(n)])
    double_squares = [2 * n ** 2 for n in range(1, int(n ** 0.5))]
    for i in range(4, n):
        if i in prime_numbers or i % 2 == 0:
            continue
        for d_s in double_squares:
            if d_s >= i:
                break
            if i - d_s in prime_numbers:
                res.add(i)
                break
    result = []
    for i in nums:
        if i not in res:
            result.append(i)
    return min(result)


# print(problem_46())


"""
Задача 47
Первые два последовательные числа, каждое из которых имеет два отличных друг 
от друга простых множителя:
14 = 2 × 7
15 = 3 × 5
Первые три последовательные числа, каждое из которых имеет три отличных друг 
от друга простых множителя:
644 = 2² × 7 × 23
645 = 3 × 5 × 43
646 = 2 × 17 × 19.
Найдите первые четыре последовательных числа, каждое из которых имеет четыре 
отличных друг от друга простых множителя. Каким будет первое число?
"""


@timer
def problem_47(n=4):
    stack = 0
    for i in range(1, 140000):
        divs = divisors(i)
        divs = [n for n in divs if is_prime(n) and n != 1]
        if len(divs) >= n:
            stack += 1
        else:
            stack = 0
        if stack == n:
            print(i - 3)


# print(problem_47())


"""
Задача 48
Сумма 1^1 + 2^2 + 3^3 + ... + 10^10 = 10405071317.
Найдите последние десять цифр суммы 1^1 + 2^2 + 3^3 + ... + 1000^1000.
"""


@timer
def problem_48(n=1000):
    res = 0
    for i in range(1, n + 1):
        res += i ** i
    return str(res)[-10:]


# print(problem_48())


"""
Задача 49
Арифметическая прогрессия: 1487, 4817, 8147, в которой каждый член возрастает 
на 3330, необычна в двух отношениях: (1) каждый из трех членов является простым числом,
(2) все три четырехзначные числа являются перестановками друг друга.
Не существует арифметических прогрессий из трех однозначных, двухзначных и 
трехзначных простых чисел, демонстрирующих это свойство. Однако, существует 
еще одна четырехзначная возрастающая арифметическая прогрессия.
Какое 12-значное число образуется, если объединить три члена этой прогрессии?
"""


@timer
def problem_49():
    for i in range(1000, 9999):
        if is_prime(i) and i != 1487:
            if is_prime(i + 3330) and is_prime(i + 2 * 3330):
                if set(list(str(i))) == set(list(str(i + 3330))) and set(list(str(i))) == set(list(str(i + 2 * 3330))):
                    return str(i) + str(i + 3330) + str(i + 2 * 3330)


# print(problem_49())


"""
Задача 50
Простое число 41 можно записать в виде суммы шести последовательных простых чисел:
41 = 2 + 3 + 5 + 7 + 11 + 13
Это - самая длинная сумма последовательных простых чисел, в результате которой
получается простое число меньше одной сотни.
Самая длинная сумма последовательных простых чисел, в результате которой получается
простое число меньше одной тысячи, содержит 21 слагаемое и равна 953.
Какое из простых чисел меньше одного миллиона можно записать в виде суммы 
наибольшего количества последовательных простых чисел?
"""


@timer
def problem_50(n=1000000):
    stack = 0
    res = [0, 0]
    lst = [n for n in range(2, int(n / 250)) if is_prime(n)]
    for i in range(len(lst)):
        for k in range(20, 999):
            if i + k >= len(lst):
                break
            if is_prime(sum(lst[i:i + k])) and sum(lst[i:i + k]) <= n:
                stack = k
            else:
                if res[0] < stack:
                    res[0] = stack
                    res[1] = sum(lst[i:i + k - 1])
    return res


# print(problem_50())


"""
Задача 51
Меняя первую цифру числа *3 (двузначного числа, заканчивающегося цифрой 3), 
оказывается, что шесть из девяти возможных значений - 13, 23, 43, 53, 73 и 83 - 
являются простыми числами.
При замене третьей и четвертой цифры числа 56**3 одинаковыми цифрами, получаются 
десять чисел, из которых семь - простые: 56003, 56113, 56333, 56443, 56663, 56773 и 56993. 
Число 56**3 является наименьшим числом, подставление цифр в которое дает именно семь 
простых чисел. Соответственно, число 56003, будучи первым из полученных простых чисел, 
является наименьшим простым числом, обладающим указанным свойством.
Найдите наименьшее простое число, которое является одним из восьми простых чисел, 
полученных заменой части цифр (не обязательно соседних) одинаковыми цифрами.
"""

""" 
Комментарий
Хоть тут и не сказано о количестве 'части цифр', минимальное число цифр должно быть 3 или более. 
Вот почему. Как известно, если сумма цифр числа кратна трём, то и само число кратно 3.
Следовательно если мы последовательно будем прибавлять к любому 
числу (которое является суммой цифр числа) едицицу, то мы как минимум трижды пересечём число кратное 3.
Так же происходит и с прибавлением двух (цифры должны быть одинаковые 00-11-22-33-44).
А вот изменяя 3 одинаковых цифры в числе другими тремя цифрами мы не получим число кратное 3, 
если изначально оно не было кратно 3.
Это сильно сужает перечень подходящих простых чисел, т.к. в нём должны изначально повторяться как минимум 3 цифры.
Для подсчёта повторяющихся символов можно использовать Counters из модуля ollections, 
но можно сделать и свой медленный велосипед.
"""


@timer
def problem_51(n=8):
    def is_meet_number(num):  # Есть ли в числе 3+ повторяющиеся цифры
        num = str(num)
        if len(num) - len(set(num)) < 3:
            return False
        for char in set(num):
            if list(num).count(char) >= 3:
                return True
        return False

    def get_list_numbers(num):  # Возвращает список всех чисел с перестановками
        num = str(num)
        res_list = []
        nums = [str(i) for i in range(10)]

        for char in set(num):
            if list(num).count(char) >= 3:
                for n in nums:
                    res_list.append(int(num.replace(char, n)))
                return set(res_list)

    primes = {i for i in range(2, 1000000) if is_prime(i) and is_meet_number(i)}
    for prime in primes:
        if len(primes.intersection(get_list_numbers(prime))) >= 8:
            return min(primes.intersection(get_list_numbers(prime)))


# print(problem_51())


"""
Задача 52
Найдите такое наименьшее натуральное число x, чтобы 
2x, 3x, 4x, 5x и 6x состояли из одних и тех же цифр.
"""


@timer
def problem_52():
    n = 0
    while True:
        n += 1
        if set(str(n * 2)) == set(str(n * 3)) == set(str(n * 4)) == set(str(n * 5)) == set(str(n * 6)):
            print(n * 2, n * 3, n * 4, n * 5, n * 6)
            return n


# print(problem_52())


"""
Задача 53
Существует ровно десять способов выбора 3 элементов из множества пяти {1, 2, 3, 4, 5}:
123, 124, 125, 134, 135, 145, 234, 235, 245, и 345
В комбинаторике для этого используется обозначение 5C3 = 10.
В общем случае,
nCr = n!/(r!(n−r)!), где r ≤ n, n! = n×(n−1)×...×3×2×1 и 0! = 1.
Это значение превышает один миллион, начиная с n = 23: 23C10 = 1144066.
Cколько значений (не обязательно различных)  nCr для 1 ≤ n ≤ 100 больше одного миллиона?
"""


@timer
def problem_53(lim=100):
    res = 0
    for n in range(1, lim + 1):
        for r in range(1, lim + 1):
            if r <= n:
                c = factorial(n) / (factorial(r) * factorial(n - r))
                if c > 1000000:
                    res += 1
    return res


# print(problem_53())


"""
Задача 54
В карточной игре покер ставка состоит из пяти карт и оценивается 
от самой младшей до самой старшей в следующем порядке:
Старшая карта: Карта наибольшего достоинства.
Одна пара: Две карты одного достоинства.
Две пары: Две различные пары карт
Тройка: Три карты одного достоинства.
Стрейт: Все пять карт по порядку, любые масти.
Флаш: Все пять карт одной масти.
Фул-хаус: Три карты одного достоинства и одна пара карт.
Каре: Четыре карты одного достоинства.
Стрейт-флаш: Любые пять карт одной масти по порядку.
Роял-флаш: Десятка, валет, дама, король и туз одной масти.
Достоинство карт оценивается по порядку:
2, 3, 4, 5, 6, 7, 8, 9, 10, валет, дама, король, туз.
Если у двух игроков получились ставки одного порядка, то выигрывает 
тот, у кого карты старше: к примеру, две восьмерки выигрывают две пятерки 
(см. пример 1 ниже). Если же достоинства карт у игроков одинаковы, к примеру, 
у обоих игроков пара дам, то сравнивают карту наивысшего достоинства (см. пример 4 ниже); 
если же и эти карты одинаковы, сравнивают следующие две и т.д.
Допустим, два игрока сыграли 5 ставок следующим образом:
Ставка	 	1-й игрок	 	2-й игрок	 	Победитель
1	 	5♥ 5♣ 6♠ 7♠ K♦
Пара пятерок
 	2♣ 3♠ 8♠ 8♦ T♦
Пара восьмерок
 	2-й игрок
2	 	5♦ 8♣ 9♠ J♠ A♣
Старшая карта туз
 	2♣ 5♣ 7♦ 8♠ Q♥
Старшая карта дама
 	1-й игрок
3	 	2♦ 9♣ A♠ A♥ A♣
Три туза
 	3♦ 6♦ 7♦ T♦ Q♦
Флаш, бубны
 	2-й игрок
4	 	4♦ 6♣ 9♥ Q♥ Q♣
Пара дам
Старшая карта девятка
 	3♦ 6♦ 7♥ Q♦ Q♠
Пара дам
Старшая карта семерка
 	1-й игрок
5	 	2♥ 2♦ 4♣ 4♦ 4♠
Фул-хаус
Три четверки
 	3♣ 3♦ 3♠ 9♠ 9♦
Фул-хаус
Три тройки
 	1-й игрок
Файл poker.txt содержит одну тысячу различных ставок для игры двух игроков. 
В каждой строке файла приведены десять карт (отделенные одним пробелом): первые пять - 
карты 1-го игрока, оставшиеся пять - карты 2-го игрока. Можете считать, что все ставки 
верны (нет неверных символов или повторов карт), ставки каждого игрока не следуют в 
определенном порядке, и что при каждой ставке есть безусловный победитель.
Сколько ставок выиграл 1-й игрок?
Примечание: карты в текстовом файле обозначены в соответствии с английскими наименованиями 
достоинств и мастей: T - десятка, J - валет, Q - дама, K - король, A - туз; S - пики, 
C - трефы, H - червы, D - бубны.
"""


@timer
def problem_54():
    """Функции, которые начинаются с 'is_' возвращают False если комбинация отсутствует,
    а если такая комбинация есть то возвращает число, х_уу_уу_уу_уу_уу,
    где х - комбинация (от 9 - флэш роял до 0 - старшая карта, а
    уу - карты в порядке значимости и убывания.
    Любая комбинация описанная таким способом даёт число, которое можно сравнивать с другим
    и выявлять более сильную комбинацию путём сравнения этих чисел."""
    def get_comps(file="files/p054_poker.txt"):
        with open(file) as file:
            text = file.read()
        return text.split("\n")[:-1]

    def get_comps_players(s: str):
        s = s.replace("2", "02")
        s = s.replace("3", "03")
        s = s.replace("4", "04")
        s = s.replace("5", "05")
        s = s.replace("6", "06")
        s = s.replace("7", "07")
        s = s.replace("8", "08")
        s = s.replace("9", "09")
        s = s.replace("T", "10")
        s = s.replace("J", "11")
        s = s.replace("Q", "12")
        s = s.replace("K", "13")
        s = s.replace("A", "14")
        s = s.split(" ")
        for i, sim in enumerate(s):
            s[i] = [s[i][:-1], s[i][-1]]
        s1 = s[:5]
        s2 = s[5:]
        return s1, s2

    def is_royal_flush(lst: list):
        suit = set()
        value = set()
        for i in lst:
            value.add(i[0])
            suit.add(i[1])
        if len(suit) == 1 and value == {"10", "11", "12", "13", "14"}:
            return 90000000000
        else:
            return False

    def is_straight_flush(lst: list):
        suit = set()
        value = set()
        for i in lst:
            value.add(i[0])
            suit.add(i[1])
        if len(suit) == 1 and len(value) == 5:
            lst = sorted(list(value), reverse=True)
            for ind, el in enumerate(lst[:-1]):
                if int(el) - int(lst[ind + 1]) == 1:
                    continue
                else:
                    return False
            return int("8" + "".join(lst))
        else:
            return False

    def is_four_of_kind(lst: list):
        suit = []
        value = []
        for i in lst:
            value.append(i[0])
            suit.append(i[1])
        value = sorted(value)
        if len(set(value[1:])) == 1:
            return int("7" + "".join(value[1:]) + value[0])
        if len(set(value[:-1])) == 1:
            return int("7" + "".join(value[:-1]) + value[-1])
        else:
            return False

    def is_full_house(lst: list):
        suit = []
        value = []
        for i in lst:
            value.append(i[0])
            suit.append(i[1])
        value = sorted(value)
        if len(set(value[2:])) == 1 and len(set(value[:2])) == 1:
            return int("6" + "".join(value[2:]) + "".join(value[:2]))
        if len(set(value[3:])) == 1 and len(set(value[:3])) == 1:
            return int("6" + "".join(value[:3]) + "".join(value[3:]))
        else:
            return False

    def is_flush(lst: list):
        suit = set()
        value = []
        for i in lst:
            value.append(i[0])
            suit.add(i[1])
        value = sorted(value, reverse=True)
        if len(suit) == 1:
            return int("5" + "".join(value))
        else:
            return False

    def is_straight(lst: list):
        value = []
        for i in lst:
            value.append(i[0])
        value = sorted(value, reverse=True)
        if len(set(value)) == 5 and int(value[0]) - int(value[4]) == 4:
            return int("4" + "".join(value))
        else:
            return False

    def is_three_of_kind(lst: list):
        value = []
        for i in lst:
            value.append(i[0])
        value = sorted(value, reverse=True)
        if len(set(value)) == 3:
            if len(set(value[:3])) == 1:
                return int("3" + "".join(value[:3]) + value[3] + value[4])
            if len(set(value[1:4])) == 1:
                return int("3" + "".join(value[1:4]) + value[0] + value[4])
            if len(set(value[2:])) == 1:
                return int("3" + "".join(value[2:]) + value[0] + value[1])
        else:
            return False

    def is_two_pairs(lst: list):
        value = []
        for i in lst:
            value.append(i[0])
        value = sorted(value, reverse=True)
        if len(set(value)) == 3:
            if len(set(value[:2])) == 1 and len(set(value[3:])) == 1:
                return int("2" + "".join(value[:2]) + value[3] + value[4] + value[2])
            if len(set(value[:2])) == 1 and len(set(value[2:4])) == 1:
                return int("2" + "".join(value[:2]) + value[2] + value[3] + value[4])
            if len(set(value[1:3])) == 1 and len(set(value[3:])) == 1:
                return int("2" + "".join(value[1:3]) + value[3] + value[4] + value[0])
        else:
            return False

    def is_one_pairs(lst: list):
        value = []
        for i in lst:
            value.append(i[0])
        value = sorted(value, reverse=True)
        if len(set(value)) == 4:
            if len(set(value[:2])) == 1:
                return int("1" + "".join(value[:2]) + value[2] + value[3] + value[4])
            if len(set(value[1:3])) == 1:
                return int("1" + "".join(value[1:3]) + value[0] + value[3] + value[4])
            if len(set(value[2:4])) == 1:
                return int("1" + "".join(value[2:4]) + value[0] + value[1] + value[4])
            if len(set(value[3:])) == 1:
                return int("1" + "".join(value[3:]) + value[0] + value[1] + value[2])
        else:
            return False

    def is_high_card(lst: list):
        suit = set()
        value = []
        for i in lst:
            value.append(i[0])
            suit.add(i[1])
        value = sorted(value, reverse=True)
        if len(set(value)) == 5 and len(suit) > 1:
            return int("0" + "".join(value))
        else:
            return False

    res = 0
    lst_comps = get_comps()
    for comp in lst_comps:
        s1, s2 = get_comps_players(comp)
        if is_royal_flush(s1): s1 = is_royal_flush(s1)
        elif is_straight_flush(s1): s1 = is_straight_flush(s1)
        elif is_four_of_kind(s1): s1 = is_four_of_kind(s1)
        elif is_full_house(s1): s1 = is_full_house(s1)
        elif is_flush(s1): s1 = is_flush(s1)
        elif is_straight(s1): s1 = is_straight(s1)
        elif is_three_of_kind(s1): s1 = is_three_of_kind(s1)
        elif is_two_pairs(s1): s1 = is_two_pairs(s1)
        elif is_one_pairs(s1): s1 = is_one_pairs(s1)
        elif is_high_card(s1): s1 = is_high_card(s1)

        if is_royal_flush(s2): s2 = is_royal_flush(s2)
        elif is_straight_flush(s2): s2 = is_straight_flush(s2)
        elif is_four_of_kind(s2): s2 = is_four_of_kind(s2)
        elif is_full_house(s2): s2 = is_full_house(s2)
        elif is_flush(s2): s2 = is_flush(s2)
        elif is_straight(s2): s2 = is_straight(s2)
        elif is_three_of_kind(s2): s2 = is_three_of_kind(s2)
        elif is_two_pairs(s2): s2 = is_two_pairs(s2)
        elif is_one_pairs(s2): s2 = is_one_pairs(s2)
        elif is_high_card(s2): s2 = is_high_card(s2)

        if s1 > s2:
            res += 1
    return res


# print(problem_54())


"""
Задача 55
Если взять число 47, перевернуть его и прибавить к исходному, т.е. найти 
47 + 74 = 121, получится палиндром.
Не из всех чисел таким образом сразу получается палиндром. К примеру,
349 + 943 = 1292
1292 + 2921 = 4213
4213 + 3124 = 7337
Т.е., понадобилось 3 итерации для того, чтобы превратить число 349 в палиндром.
Хотя никто еще этого не доказал, считается, что из некоторых чисел, таких как 196, 
невозможно получить палиндром. Такое число, которое не образует палиндром путем 
переворачивания и сложения с самим собой, называется числом Личрэла. Ввиду теоретической 
природы таких чисел, а также цели этой задачи, мы будем считать, что число является 
числом Личрэла до тех пор, пока не будет доказано обратное. Помимо этого дано, что 
любое число меньше десяти тысяч либо (1) станет палиндромом меньше, чем за 50 итераций, 
либо (2) никто, с какой бы-то ни было вычислительной мощностью, не смог получить из 
него палиндром. Между прочим, 10677 является первым числом, для которого необходимо 
более 50 итераций, чтобы получить палиндром: 4668731596684224866951378664 
(53 итерации, 28-значное число).
На удивление, есть такие палиндромы, которые одновременно являются и числами 
Личрэла; первое такое число - 4994.
Сколько существует чисел Личрэла меньше десяти тысяч?
ПРИМЕЧАНИЕ: Формулировка задачи была немного изменена 24 апреля 2007 года, 
чтобы подчеркнуть теоретическую природу чисел Личрэла.
"""

@timer
def problem_55(t=10000):
    res = []
    result = []
    for i in range(1, t + 1):
        stack = 1
        n = i
        for k in range(50):
            n = int(str(n)[::-1]) + n
            if is_palindrome(str(n)):
                res.append(i)
                break
            else:
                stack += 1
    for i in range(1, t + 1):
        if i not in res:
            result.append(i)
    return len(result)


# print(problem_55())


"""
Задача 56
Гугол (10100) - гигантское число: один со ста нулями; 100100 почти невообразимо 
велико: один с двумястами нулями. Несмотря на их размер, сумма цифр каждого числа 
равна всего лишь 1.
Рассматривая натуральные числа вида ab, где a, b < 100, какая встретится максимальная 
сумма цифр числа?
"""

@timer
def problem_56(a=100, b=100):
    res = 0
    for i in range(1, a+1):
        for k in range(1, b+1):
            a = sum([int(j) for j in str(i**k)])
            if a > res:
                res = a
    return res

# print(problem_56())


"""
Задача 57
Можно убедиться в том, что квадратный корень из двух можно выразить в виде 
бесконечно длинной дроби.
√ 2 = 1 + 1/(2 + 1/(2 + 1/(2 + ... ))) = 1.414213...
Приблизив это выражение для первых четырех итераций, получим:
1 + 1/2 = 3/2 = 1.5
1 + 1/(2 + 1/2) = 7/5 = 1.4
1 + 1/(2 + 1/(2 + 1/2)) = 17/12 = 1.41666...
1 + 1/(2 + 1/(2 + 1/(2 + 1/2))) = 41/29 = 1.41379...
Следующие три приближения: 99/70, 239/169 и 577/408, а восьмое приближение, 
1393/985, является первым случаем, в котором количество цифр в числителе 
превышает количество цифр в знаменателе.
У скольких дробей длина числителя больше длины знаменателя в первой тысяче 
приближений выражения?
"""

@timer
def problem_57(n=10000):
    x1, x2, res = 1, 2, 0
    for i in range(n-1):
        x1, x2 = x2, 2 * x2 + x1
        if not len(str(x1+x2)) == len(str(x2)):
            res += 1
    return res

# print(problem_57())


"""
Задача 58
Начиная с 1 и продвигаясь по спирали в направлении против часовой стрелки, получается 
квадратная спираль с длиной стороны 7
37 36 35 34 33 32 31
38 17 16 15 14 13 30
39 18  5  4  3 12 29
40 19  6  1  2 11 28
41 20  7  8  9 10 27
42 21 22 23 24 25 26
43 44 45 46 47 48 49
Интересно заметить, что нечетные квадраты лежат на правой нижней полудиагонали. Еще интереснее 
то, что среди 13 чисел, лежащих на обеих диагоналях, 8 являются простыми; т.е. отношение составляет 
8/13 ≈ 62%.
Если добавить еще один целый слой вокруг изображенной выше спирали, получится квадратная спираль 
с длиной стороны 9. Если продолжать данный процесс, какой будет длина стороны квадратной спирали, 
у которой отношение количества простых чисел к количеству всех чисел на обеих диагоналях упадет ниже 10%?
"""


@timer
def problem_58(n=0.1):
    all_nums = 1
    prime_nums = 0
    i = 3
    while True:
        x1 = i ** 2
        x2 = i ** 2 - 1 * (i - 1)
        x3 = i ** 2 - 2 * (i - 1)
        x4 = i ** 2 - 3 * (i - 1)
        all_nums += len([x1, x2, x3, x4])
        prime_nums += len([x for x in [x1, x2, x3, x4] if is_prime(x)])
        if prime_nums / all_nums <= n:
            return i
        i += 2

# print(problem_58())


"""

Каждый символ в компьютере имеет уникальный код, предпочитаемым является стандарт ASCII 
(American Standard Code for Information Interchange - Американский стандартный код для обмена 
информацией). Для примера, A верхнего регистра = 65, звездочка (*) = 42, а k нижнего регистра = 107.
Современный метод шифровки состоит в том, что берется текстовый файл, конвертируется в байты 
по ASCII, а потом над каждым байтом выполняется операция XOR с определенным значением, взятым 
из секретного ключа. Преимущество функции XOR состоит в том, что применяя тот же ключ к 
зашифрованному тексту, получается исходный; к примеру, 65 XOR 42 = 107, тогда 107 XOR 42 = 65.
Для невзламываемого шифрования ключ должен быть такой же длины, что и сам текст, и ключ 
должен быть составлен из случайных байтов. Тогда, если пользователь хранит зашифрованное 
сообщение и ключ шифрования в разных местах, то без обеих "половинок" расшифровать сообщение просто невозможно.
К сожалению, этот метод непрактичен для большинства пользователей, поэтому упрощенный 
метод использует в качестве ключа пароль. Если пароль короче текстового сообщения, что 
наиболее вероятно, то ключ циклично повторяется на протяжении всего сообщения. Идеальный 
пароль для этого метода достаточно длинный, чтобы быть надежным, но достаточно короткий, 
чтобы его можно было запомнить.
Ваша задача была упрощена, так как пароль состоит из трех символов нижнего регистра. 
Используя cipher1.txt (щелкнуть правой кнопкой мыши и выбрать 'Save Link/Target As...'), 
содержащий зашифрованные коды ASCII, а также тот факт, что сообщение должно содержать 
распространенные английские слова, расшифруйте сообщение и найдите сумму всех значений 
ASCII в исходном тексте.
"""

def get_list_from_file(file="files/p059_cipher.txt"):
    with open(file) as file:
        text = file.read().split(",")
    return [int(x) for x in text]



@timer
def problem_59():
    lst = get_list_from_file()
    for i1 in range(97, 123):
        for i2 in range(97, 123):
            for i3 in range(97, 123):
                short_lst = lst[:]
                short_lst[::3] = [x ^ i1 for x in short_lst[::3]]
                short_lst[1::3] = [x ^ i2 for x in short_lst[1::3]]
                short_lst[2::3] = [x ^ i3 for x in short_lst[2::3]]
                text = "".join([chr(i) for i in short_lst])
                if "and" in text and "from" in text:
                    print(text)
                    return sum([ord(i) for i in text])


# print(problem_59())


"""
Задача 60
Простые числа 3, 7, 109 и 673 достаточно замечательны. Если взять любые 
два из них и объединить их в произвольном порядке, в результате всегда 
получится простое число. Например, взяв 7 и 109, получатся простые числа 
7109 и 1097. Сумма этих четырех простых чисел, 792, представляет собой 
наименьшую сумму элементов множества из четырех простых чисел, обладающих 
данным свойством.
Найдите наименьшую сумму элементов множества из 5 простых чисел, для которых 
объединение любых двух даст новое простое число.
"""


def combinations(iterable, r):
    # combinations('ABCD', 2) --> AB AC AD BC BD CD
    # combinations(range(4), 3) --> 012 013 023 123
    pool = tuple(iterable)
    n = len(pool)
    if r > n:
        return
    indices = list(range(r))
    yield tuple(pool[i] for i in indices)
    while True:
        for i in reversed(range(r)):
            if indices[i] != i + n - r:
                break
        else:
            return
        indices[i] += 1
        for j in range(i+1, r):
            indices[j] = indices[j-1] + 1
        yield tuple(pool[i] for i in indices)

"""
1) Чистый брутфорс - приведенный решённый пример решается за 61485 мс
2) Добавлены такие условия    if 3 in i:
                                if sum(i) % 3 != 0:
                                    continue
                              else:
                                if sum(i) % 3 == 0:
                                    continue
   решается за 42907 мс

"""
@timer
def problem_60(n=5):
    prime_list = [i for i in range(2, 10000) if is_prime(i)]
    combinations_list = combinations(prime_list, r=n)
    for i in combinations_list:
        if 3 in i:
            if sum(i) % 3 == 0:
                continue
        perm = permutations(i, r=2)
        res = [is_prime(int("".join(map(str, k)))) for k in perm]
        if all(res):
            return i


print(problem_60())
