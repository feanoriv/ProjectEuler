# Декоратор - таймер
from functools import wraps
from time import time
import cProfile

def profile(func):
    """Decorator for run function profile"""
    def wrapper(*args, **kwargs):
        profile_filename = func.__name__ + '.prof'
        profiler = cProfile.Profile()
        result = profiler.runcall(func, *args, **kwargs)
        profiler.dump_stats(profile_filename)
        return result
    return wrapper

def timer(func):
    @wraps(func)
    def _time_it(*args, **kwargs):
        start = int(round(time() * 1000))
        try:
            return func(*args, **kwargs)
        finally:
            end_ = int(round(time() * 1000)) - start
            print(f"Функция {func.__name__} с аргументом/и {args}, - завершилась за: {end_ if end_ > 0 else 0} ms")

    return _time_it


"""
Задача 1
Если выписать все натуральные числа меньше 10, кратные 3 или 5, то получим 3, 5, 6 и 9.
Сумма этих чисел равна 23.
Найдите сумму всех чисел меньше 1000, кратных 3 или 5.
"""


@timer
def problem_1(n):
    return sum([a for a in range(n) if a % 3 == 0 or a % 5 == 0])


# print(problem_1(1000))

"""
Задача 2
Каждый следующий элемент ряда Фибоначчи получается при сложении двух предыдущих. 
Начиная с 1 и 2, первые 10 элементов будут:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
Найдите сумму всех четных элементов ряда Фибоначчи, которые не превышают четыре миллиона.
"""


@timer
def problem_2(n):
    i1 = 1
    i2 = 2
    res = 0
    while i2 < n:
        i3 = i1 + i2
        if i2 % 2 == 0:
            res += i2
        i1, i2 = i2, i3
    return res


# print(problem_2(4000000))

"""
Задача 3
Простые делители числа 13195 - это 5, 7, 13 и 29.
Каков самый большой делитель числа 600851475143, являющийся простым числом?
"""


@timer
def problem_3(n):
    square_root = int(n ** 0.5)
    for i in range(square_root, 0, -1):
        if n % i == 0:
            if i > 3:
                flag = True
                for k in range(2, i):
                    if i % k == 0:
                        flag = False
                        continue
                if flag:
                    return i


# print(problem_3(600851475143))

"""
Задача 4
Число-палиндром с обеих сторон (справа налево и слева направо) читается одинаково. 
Самое большое число-палиндром, полученное умножением двух двузначных чисел – 9009 = 91 × 99.
Найдите самый большой палиндром, полученный умножением двух трехзначных чисел.
"""


@timer
def problem_4(n: int):  # n - разрядность чисел
    list_palindrome = []
    n1, n2 = int(n * "9"), int(n * "9")
    for i in range(n1, 0, -1):
        for k in range(n2, 0, -1):
            if str(i * k) == str(i * k)[::-1]:
                list_palindrome.append(i * k)
    return max(list_palindrome)


# print(problem_4(3))

"""
Задача 5
2520 - самое маленькое число, которое делится без остатка на все числа от 1 до 10.
Какое самое маленькое число делится нацело на все числа от 1 до 20?
"""


def sieve_of_Eratosthenes(n: int) -> list:
    lst = list(range(2, n + 1))
    i, k = 0, 0
    sqrt_n = int(n ** 0.5) + 1
    while sqrt_n >= k:
        k = lst[i]
        lst = [x for x in lst if x % k != 0]
        lst.insert(i, k)
        i += 1
    return lst


def is_prime(n):
    if n in (1, 2, 3):
        return True
    if n % 2 == 0:
        return False
    for k in range(3, int(n ** 0.5) + 1, 2):
        if n % k == 0:
            return False
    else:
        return True


def multiply(lst):
    res = 1
    for elem in lst:
        res *= elem
    return res


@timer
def problem_5(n):
    list_simple_numbers = [x for x in range(1, n + 1) if is_prime(x)]
    step = multiply(list_simple_numbers)
    res = 0
    while res <= multiply(list(range(1, n + 1))):
        res += step
        if all([res % x == 0 for x in list(range(1, n + 1))]):
            return res


# Удивительная разница во времени расчётах между числом 120 и 130 для этой функции
# print(problem_5(20))

"""
Задача 6
Сумма квадратов первых десяти натуральных чисел равна
1^2 + 2^2 + ... + 10^2 = 385
Квадрат суммы первых десяти натуральных чисел равен
(1 + 2 + ... + 10)^2 = 552 = 3025
Следовательно, разность между суммой квадратов и квадратом суммы первых десяти 
натуральных чисел составляет 3025 − 385 = 2640.
Найдите разность между суммой квадратов и квадратом суммы первых ста натуральных чисел.
"""


@timer
def problem_6(n):
    return sum(list(range(n + 1))) ** 2 - sum([x ** 2 for x in range(n + 1)])


# print(problem_6(100))

"""
Задача 7
Выписав первые шесть простых чисел, получим 2, 3, 5, 7, 11 и 13. Очевидно, что 6-е простое число - 13.
Какое число является 10001-м простым числом?
"""


@timer
def problem_7(n):
    number = 2
    number_primary = 0
    while True:
        if is_prime(number):
            number_primary += 1
            if number_primary == n:
                return number
        number += 1


# print(problem_7(10001))

"""
Задача 8
Наибольшее произведение четырех последовательных цифр в нижеприведенном 
1000-значном числе равно 9 × 9 × 8 × 9 = 5832.
"""
str_number = """
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450
"""
"""
Найдите наибольшее произведение тринадцати последовательных цифр в данном числе.
"""


@timer
def problem_8(n):  # Число символов
    res = []
    number = str_number.replace("\n", "")
    for i in range(len(number) - n - 1):
        str_sequence = number[i:i + n]
        lst_int = []
        for elem in str_sequence:
            lst_int.append(int(elem))
        res.append(multiply(lst_int))
    return max(res)


# print(problem_8(13))

"""
Задача 9
Тройка Пифагора - три натуральных числа a < b < c, для которых выполняется равенство
a^2 + b^2 = c^2
Например, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
Существует только одна тройка Пифагора, для которой a + b + c = 1000.
Найдите произведение abc.
"""


@timer
def problem_9(s=1000):
    for a in range(3, s):
        for b in range(4, s):
            c = (a ** 2 + b ** 2) ** 0.5
            if a + b + c == s:
                return multiply([a, b, c])


# print(problem_9(1000))

"""
Задача 10
Сумма простых чисел меньше 10 равна 2 + 3 + 5 + 7 = 17.
Найдите сумму всех простых чисел меньше двух миллионов.
"""


@timer
def problem_10(n):  # n - до скольки считать
    return sum(sieve_of_Eratosthenes(n))


# print(problem_10(2000000))

"""
Задача 11
В таблице 20×20 (внизу) четыре числа на одной диагонали выделены красным.
08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48

Произведение этих чисел 26 × 63 × 78 × 14 = 1788696.
Каково наибольшее произведение четырех подряд идущих чисел в таблице 20×20, 
расположенных в любом направлении (вверх, вниз, вправо, влево или по диагонали)?
"""


def table_conversion_in_list_of_list(file: str):
    with open(file) as file:
        tbl = file.read()
    lst_row = tbl.split("\n")
    for i, row in enumerate(lst_row):
        lst_row[i] = row.split()
        for ind, elem in enumerate(lst_row[i]):
            lst_row[i][ind] = int(elem)
    return lst_row


@timer
def problem_11(n=4):
    lst_of_lst = table_conversion_in_list_of_list("files/greed.txt")
    res_lst = []
    for i in range(len(lst_of_lst)):
        for j in range(0, len(lst_of_lst[i]) - 3):
            res_lst.append(lst_of_lst[i][j] * lst_of_lst[i][j + 1] *
                           lst_of_lst[i][j + 2] * lst_of_lst[i][j + 3])
    for i in range(len(lst_of_lst) - 3):
        for j in range(0, len(lst_of_lst[i])):
            res_lst.append(lst_of_lst[i][j] * lst_of_lst[i + 1][j] *
                           lst_of_lst[i + 2][j] * lst_of_lst[i + 3][j])
    for i in range(len(lst_of_lst) - 3):
        for j in range(0, len(lst_of_lst[i]) - 3):
            res_lst.append(lst_of_lst[i][j] * lst_of_lst[i + 1][j + 1] *
                           lst_of_lst[i + 2][j + 2] * lst_of_lst[i + 3][j + 3])
    for i in range(len(lst_of_lst) - 3):
        for j in range(0, len(lst_of_lst[i]) - 3):
            res_lst.append(lst_of_lst[i][j + 3] * lst_of_lst[i + 1][j + 2] *
                           lst_of_lst[i + 2][j + 1] * lst_of_lst[i + 3][j])
    return max(res_lst)


# print(problem_11(4))

"""
Задача 12
Последовательность треугольных чисел образуется путем сложения натуральных чисел. 
К примеру, 7-е треугольное число равно 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
Первые десять треугольных чисел:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
Перечислим делители первых семи треугольных чисел:
 1: 1
 3: 1, 3
 6: 1, 2, 3, 6
10: 1, 2, 5, 10
15: 1, 3, 5, 15
21: 1, 3, 7, 21
28: 1, 2, 4, 7, 14, 28
Как мы видим, 28 - первое треугольное число, у которого более пяти делителей.
Каково первое треугольное число, у которого более пятисот делителей?
"""


def how_divisors_have(n):
    res = 1
    if n == 0:
        return 0
    if n == 1:
        return 1
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            res += 2
    if n / n ** 0.5 % 1 == 0:
        res -= 1
    return res + 1


@timer
def problem_12(n=500):
    i = 1
    while True:
        number = sum(range(i))
        divis = how_divisors_have(number)
        i += 1
        if divis >= n:
            return i, number, divis


""" Тут 1 секунда - вычисление sum(range(i)), остальные 6 секунд - подсчёт 
кол-ва делителей числа функцией how_divisors_have(). Есть в сети алгоритмы."""
# print(problem_12())

"""
Задача 13
Найдите первые десять цифр суммы следующих ста 50-значных чисел. Имя файла "50numbers.txt"
"""


def parse_numbers(file: str):
    with open(file) as file:
        text = file.read()
    text = text.split('\n')
    for i, elem in enumerate(text):
        text[i] = int(elem)
    return text


@timer
def problem_13():
    lst = parse_numbers("files/50numbers.txt")
    return str(sum(lst))[:10]


# print(problem_13())

"""
Задача 14
Следующая повторяющаяся последовательность определена для множества натуральных чисел:
n → n/2 (n - четное)
n → 3n + 1 (n - нечетное)
Используя описанное выше правило и начиная с 13, сгенерируется следующая последовательность:
13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
Получившаяся последовательность (начиная с 13 и заканчивая 1) содержит 10 элементов. Хотя это до сих пор и не доказано (проблема Коллатца (Collatz)), предполагается, что все сгенерированные таким образом последовательности оканчиваются на 1.
Какой начальный элемент меньше миллиона генерирует самую длинную последовательность?
Примечание: Следующие за первым элементы последовательности могут быть больше миллиона.
"""


@timer
def problem_14(n=1000000):
    res = [1, 1]
    dict_results = {}
    for ind in range(1, 1000000):
        i = ind
        k = 1
        while i != 1:
            if i % 2 == 0:
                i = i / 2
                k += 1
            else:
                i = 3 * i + 1
                k += 1
            if i in dict_results.keys():  # Если ключ уже есть, то нет необходимости ещё раз считать
                k += dict_results[i]
                i = 1
            if i == 1:
                dict_results[ind] = k  # В словарь добавляются {число:путь}
                if res[1] < k:
                    res = [ind, k]
    return res


""" Добавление словаря пройденных путей позволило уменьшить скорость работы 
алгоритма с 45 до 3 секунд, я рад =)"""

# print(problem_14())

"""
Задача 15
Начиная в левом верхнем углу сетки 2×2 и имея возможность двигаться только 
вниз или вправо, существует ровно 6 маршрутов до правого нижнего угла сетки.
Сколько существует таких маршрутов в сетке 20×20?
"""
"""
Мой комментарий
Долго вникал в то как просчитать все ячейки этой сетки, нашёл некоторые закономерности, 
но их было мало для расчёта полной сетки при n > 7-8.
После этого нашлось элегантное решение позволяющее найти 
весь верхний ряд значений для n+1 при известном n. Где решением для n будет f(n) = lst[0]
Доволен=)
"""


@timer
def problem_15(n: int) -> int:  # Принимает разрядность сетки
    n += 1  # Количество узлов в сетке на 1 больше чем разрядность
    lst = [1]
    res = [1]
    for i in range(1, n + 1):
        for k in range(len(lst)):
            res[k] = sum(lst[k:])
        res.insert(0, 2 * res[0])
        res = lst
    return res[0]


# print(problem_15(20))

"""
Задача 16
2^15 = 32768, сумма цифр этого числа равна 3 + 2 + 7 + 6 + 8 = 26.
Какова сумма цифр числа 2^1000?
"""


@timer
def problem_16(n: int) -> int:  # Сумма цифр в числе 2^n
    str_number = str(2 ** n)
    res = 0
    for num in str_number:
        res += int(num)
    return res


# print(problem_16(1000))


"""
Задача 17
Если записать числа от 1 до 5 английскими словами (one, two, three, four, five), 
то используется всего 3 + 3 + 5 + 4 + 4 = 19 букв.
Сколько букв понадобится для записи всех чисел от 1 до 1000 (one thousand) включительно?
Примечание: Не считайте пробелы и дефисы. Например, число 342 (three hundred and forty-two) 
состоит из 23 букв, число 115 (one hundred and fifteen) - из 20 букв. 
Использование "and" при записи чисел соответствует правилам британского английского."""
# dict из просторов
ones = {
    0: '', 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six',
    7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten', 11: 'eleven', 12: 'twelve',
    13: 'thirteen', 14: 'fourteen', 15: 'fifteen', 16: 'sixteen',
    17: 'seventeen', 18: 'eighteen', 19: 'nineteen'}
tens = {
    2: 'twenty', 3: 'thirty', 4: 'forty', 5: 'fifty', 6: 'sixty',
    7: 'seventy', 8: 'eighty', 9: 'ninety'}
illions = {
    1: 'thousand', 2: 'million', 3: 'billion', 4: 'trillion', 5: 'quadrillion',
    6: 'quintillion', 7: 'sextillion', 8: 'septillion', 9: 'octillion',
    10: 'nonillion', 11: 'decillion'}


@timer
def problem_17(n):
    res = 0
    # res_str = []
    for i in range(1, n + 1):
        if i // 10 <= 1:
            res += len(ones[i])
            # res_str.append(ones[i])
        elif i // 10 >= 2 and i // 10 <= 9:
            res += len(tens[i // 10]) + len(ones[i % 10])
            # res_str.append(tens[i // 10] + " " + ones[i % 10])
        elif i // 10 > 9 and i // 10 < 100:
            if i % 100 == 0:
                res += len(ones[i / 100]) + len("hundred")
                # res_str.append(ones[i / 100] + " " + "hundred")
            elif i % 100 <= 19:
                res += len(ones[i // 100]) + len("hundred") + len("and") + len(ones[i % 100])
                # res_str.append(ones[i // 100] + " " + "hundred" + " and" + " " + ones[i % 100])
            elif i % 100 >= 19:
                res += len(ones[i // 100]) + len("hundred") + len("and") + len(tens[(i % 100) // 10]) + len(
                    ones[(i % 100) % 10])
                # res_str.append(ones[i // 100] + " " + "hundred" + " and " + tens[(i % 100) // 10] + " " + ones[(i % 100) % 10])
        elif i // 1000 >= 1:
            res += len("onethousand")
    return res


# Закоменчен список текстового представления элементов
# print(problem_17(1000))

"""
Задача 18
Начиная в вершине треугольника (см. пример ниже) и перемещаясь вниз 
на смежные числа, максимальная сумма до основания составляет 23.
3
7 4
2 4 6
8 5 9 3
То есть, 3 + 7 + 4 + 9 = 23.
Найдите максимальную сумму пути от вершины до основания следующего треугольника:
Примечание: Так как в данном треугольнике всего 16384 возможных 
маршрута от вершины до основания, эту задачу можно решить 
проверяя каждый из маршрутов. Однако похожая Задача 67 с 
треугольником, состоящим из сотни строк, не решается перебором 
(brute force) и требует более умного подхода! ;o)
"""


def parse_triangle(file: str) -> list:
    with open(file) as file:
        text = file.read()
    text = text.split("\n")
    for i, elem in enumerate(text):
        text[i] = elem.split(" ")
        for k, j in enumerate(text[i]):
            text[i][k] = int(j)
    return text


@timer
def problem_18():
    lst = parse_triangle("files/triangle.txt")[::-1]  # Начало итераций с основания
    for ind, line in enumerate(lst):
        if ind == len(lst) - 1:
            return line[0]
        for i in range(len(lst[ind + 1])):
            lst[ind + 1][i] = lst[ind + 1][i] + max(lst[ind][i], lst[ind][i + 1])


# print(problem_18())

"""
Задача 19
Дана следующая информация (однако, вы можете проверить ее самостоятельно):
1 января 1900 года - понедельник.
В апреле, июне, сентябре и ноябре 30 дней.
В феврале 28 дней, в високосный год - 29.
В остальных месяцах по 31 дню.
Високосный год - любой год, делящийся нацело на 4, однако последний год века (ХХ00) 
является високосным в том и только том случае, если делится на 400.
Сколько воскресений выпадает на первое число месяца в двадцатом веке 
(с 1 января 1901 года до 31 декабря 2000 года)?
"""

mounts_days = {1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31}


@timer
def problem_19():
    year = 1900
    mount = 1
    day = 1
    weekday = 1
    year_mount_day_weekday = []
    while True:
        if (year % 4 == 0 and not year % 100 == 0) or (year % 400 == 0):
            mounts_days[2] = 29
        else:
            mounts_days[2] = 28
        year_mount_day_weekday.append([year, mount, day, weekday])

        if day < mounts_days[mount]:
            day += 1
        else:
            day = 1
            if mount < 12:
                mount += 1
            else:
                mount = 1
                year += 1
        if weekday < 7:
            weekday += 1
        else:
            weekday = 1

        if year == 2001:
            counter = 0
            for elem in year_mount_day_weekday:
                if elem[2] == 1 and elem[3] == 7 and elem[0] != 1900:
                    counter += 1
            return counter


# Минут 30 не понимал откуда лишний день взялся, нашёл пару схожих проблем на stuckoverflow, и что в итоге?
# Я считал понедельники, а не воскресенья...
# print(problem_19())


"""
Задача 20
n! означает n × (n − 1) × ... × 3 × 2 × 1
Например, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
и сумма цифр в числе 10! равна 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.
Найдите сумму цифр в числе 100!.
"""


@timer
def problem_20(n):
    factorial = 1
    for i in range(1, n + 1):
        factorial *= i
    return sum([int(x) for x in list(str(factorial))])


# print(problem_20(100))

"""
Задача 21
Пусть d(n) определяется как сумма делителей n (числа меньше n, делящие n нацело).
Если d(a) = b и d(b) = a, где a ≠ b, то a и b называются дружественной парой, 
а каждое из чисел a и b - дружественным числом.
Например, делителями числа 220 являются 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 и 110, 
поэтому d(220) = 284. Делители 284 - 1, 2, 4, 71, 142, поэтому d(284) = 220.
Подсчитайте сумму всех дружественных чисел меньше 10000.
"""


def divisors(n):
    res = [1]
    if n <= 1:
        return [0]
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0 and i ** 2 != n:
            res.append(i)
            res.append(int(n / i))
        elif i ** 2 == n:
            res.append(i)
    return res


@timer
def problem_21(n=10000):
    res = []
    for i in range(1, n + 1):
        a_num = sum(divisors(i))
        if i != a_num:
            if i == sum(divisors(a_num)):
                res.append(i)
    return res


# print(sum(problem_21()))

"""
Задача 22
Используйте names.txt (щелкнуть правой кнопкой мыши и выбрать 'Save Link/Target As...'),
текстовый файл размером 46 КБ, содержащий более пяти тысяч имен. Начните с сортировки 
в алфавитном порядке. Затем подсчитайте алфавитные значения каждого имени и умножьте 
это значение на порядковый номер имени в отсортированном списке для получения количества 
очков имени.
Например, если список отсортирован по алфавиту, имя COLIN (алфавитное значение которого 
3 + 15 + 12 + 9 + 14 = 53) является 938-м в списке. Поэтому, имя COLIN получает 938 × 53 = 49714 
очков.
Какова сумма очков имен в файле?
"""


def read_file_return_lst(file="files/names.txt"):
    with open(file) as file:
        text = file.read()
    text = text.replace('"', '').lower()
    text = text.split(",")
    return sorted(text)


char2 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
         'w', 'x', 'y', 'z']


@timer
def problem_22():
    names = read_file_return_lst()
    lst_points = []
    for ind, name in enumerate(names):
        points = 0
        for char in name:
            points += char2.index(char) + 1
        points *= (ind + 1)
        lst_points.append(points)
    return sum(lst_points)


# print(problem_22())


"""
Задача 23
Совершенным числом называется число, у которого сумма его делителей равна самому числу. 
Например, сумма делителей числа 28 равна 1 + 2 + 4 + 7 + 14 = 28, что означает, что число 
28 является совершенным числом.
Число n называется недостаточным, если сумма его делителей меньше n, и называется избыточным, 
если сумма его делителей больше n.
Так как число 12 является наименьшим избыточным числом (1 + 2 + 3 + 4 + 6 = 16), наименьшее 
число, которое может быть записано как сумма двух избыточных чисел, равно 24. Используя 
математический анализ, можно показать, что все целые числа больше 28123 могут быть записаны 
как сумма двух избыточных чисел. Эта граница не может быть уменьшена дальнейшим анализом, 
даже несмотря на то, что наибольшее число, которое не может быть записано как сумма двух 
избыточных чисел, меньше этой границы.
Найдите сумму всех положительных чисел, которые не могут быть записаны как сумма двух 
избыточных чисел.
"""


def set_abundant_numbers(n=28123) -> list:
    res = set()
    for i in range(n):
        if sum(divisors(i)) > i:
            res.add(i)
    return res


@timer
def problem_23(n=28123):
    set_amb = set_abundant_numbers()
    lst_2_amb = list(range(1, n))
    for i in range(24, n):
        for num1 in set_amb:
            if i - num1 < 0:
                break
            if i - num1 in set_amb:
                lst_2_amb.remove(i)
                break
    return sum(lst_2_amb)


""" 
---Комментарий к решению---
В течении половины дня я размышлял над тем как оптимизировать код!
Читал статьи в Вики о совершенных, избыточных и недостаточных числах.
Код работал 370 секунд, а значит существовал алгоритм, но найти я его так и не смог=(
Оставил как есть и пошёл проверять ответ, заодно глянуть что за хитрые алгоритмы мне не дались...
А нет никакого алгоритма! Чтобы код работал в 150 раз быстрее нужно было изменить list() на set()!
Впервые вижу чтобы уместно применённый тип данных так зарешал.
В своём коде изменил list на set, т.к. считаю, что задачка покорилась ибо алгоритм я не менял.
"""
# print(problem_23())


"""
ЗАдача 24
Перестановка - это упорядоченная выборка объектов. К примеру, 
3124 является одной из возможных перестановок из цифр 1, 2, 3 и 4. 
Если все перестановки приведены в порядке возрастания или алфавитном порядке, 
то такой порядок будем называть словарным. Словарные перестановки из цифр 0, 1 и 2 представлены ниже:
012   021   102   120   201   210
Какова миллионная словарная перестановка из цифр 0, 1, 2, 3, 4, 5, 6, 7, 8 и 9?
"""


def factorial(n: int) -> int:
    res = 1
    for i in range(1, n + 1):
        res *= i
    return res


@timer
def problem_24(n: int, number: int = 1000000) -> list:
    start = list(range(n))
    res = []
    for i in range(n):
        lst = []
        step = factorial(n - 1 - i)
        for k in range(1, n + 1 - i):
            lst.append(k * step)
        for ind, arr in enumerate(lst):
            if arr >= number:
                if lst[ind] != 0:
                    number = number - lst[ind - 1]
                res.append(start[lst.index(arr)])
                start.pop(lst.index(arr))
                break

    return "".join([str(x) for x in res])


""" 
---Комментарий---
Сделал вот такой интересный алгоритм со сложностью On где n - кол-во цифр,
Проверяя ответ обнаружил, что ребята использовали готовый модуль "from itertools import permutations"
и брутфорсят ответ. Их алгоритм с использованием permutations - 1187 ms, а мой - 0 ms=))))
Опять рад)
"""
# print(problem_24(n=10, number=1000000))


"""
Задача 25
Последовательность Фибоначчи определяется рекурсивным правилом:
Fn = Fn−1 + Fn−2, где F1 = 1 и F2 = 1.
Таким образом, первые 12 членов последовательности равны:
F1 = 1
F2 = 1
F3 = 2
F4 = 3
F5 = 5
F6 = 8
F7 = 13
F8 = 21
F9 = 34
F10 = 55
F11 = 89
F12 = 144
Двенадцатый член F12 - первый член последовательности, который содержит три цифры.
Каков порядковый номер первого члена последовательности Фибоначчи, содержащего 1000 цифр?
"""


def problem_25(n=1000) -> int:
    res = 2
    a1, a2 = 1, 1
    while True:
        a1, a2 = a2, a1 + a2
        res += 1
        if len(str(a2)) >= n:
            return res


# print(problem_25())

"""
Задача 26
Единичная дробь имеет 1 в числителе. Десятичные представления единичных дробей 
со знаменателями от 2 до 10 даны ниже:
1/2	=	0.5
1/3	=	0.(3)
1/4	=	0.25
1/5	=	0.2
1/6	=	0.1(6)
1/7	=	0.(142857)
1/8	=	0.125
1/9	=	0.(1)
1/10	=	0.1
Где 0.1(6) значит 0.166666..., и имеет повторяющуюся последовательность из одной цифры. 
Заметим, что 1/7 имеет повторяющуюся последовательность из 6 цифр.
Найдите значение d < 1000, для которого 1/d в десятичном виде содержит самую 
длинную повторяющуюся последовательность цифр.
"""


@timer
def problem_26(n=1000, length=3000):
    res = [0, [1]]
    for i in range(1, n + 1):
        base = 1
        lst = []
        for k in range(length):
            if base < i and base != 0:
                base *= 10
                if base < i and base != 0:
                    base *= 10
                    lst.append(0)
                    if base > i:
                        continue
                    if base < i and base != 0:
                        base *= 10
                        lst.append(0)
                        if base > i:
                            continue
                        if base < i:
                            base *= 10
                            lst.append(0)
                            if base > i:
                                continue
            if base == 0:
                lst.append(0)
            if base >= i:
                x = base // i
                base = base % i
                lst.append(x)

        flag = True
        seq = lst[::-1]
        for j in range(int(length / 3), 1, -1):
            if seq[0:j] == seq[j:j * 2] and seq[0 + 1:j + 1] != seq[0:j]:
                seq = seq[0:j]
                for k in range(1, j):
                    if seq[0:k] == seq[k:2 * k]:
                        if flag:
                            seq = seq[0:k]
                            if len(seq) > len(res[1]):
                                res[0], res[1] = i, seq
                            flag = False
                            break
                if flag:
                    if len(seq) > len(res[1]):
                        res[0], res[1] = i, seq
                        break

    return res[0], len(res[1])


""" Ответ - верный, подход - не очень"""
# print(problem_26())

"""
Задача 27
Эйлер опубликовал свою замечательную квадратичную формулу:
n^2+n+41
Оказалось, что согласно данной формуле можно получить 40 простых чисел, последовательно подставляя 
значения 0≤n≤39. Однако, при n=40, 402+40+41=40(40+1)+41 делится на 41 без остатка, и, очевидно, при 
n=41,412+41+41 делится на 41 без остатка.
При помощи компьютеров была найдена невероятная формула n2−79n+1601, согласно которой можно получить 
80 простых чисел для последовательных значений n от 0 до 79. Произведение коэффициентов −79 и 1601 равно −126479.
Рассмотрим квадратичную формулу вида:
n^2+an+b, где |a|<1000 и |b|≤1000
где |n| является модулем (абсолютным значением) n.
К примеру, |11|=11 и |−4|=4
Найдите произведение коэффициентов a и b квадратичного выражения, согласно которому можно получить 
максимальное количество простых чисел для последовательных значений n, начиная со значения n=0.
"""


@timer
def problem_27(a_max=999, b_max=1000):
    res = [0, []]
    for b in range(b_max + 1):
        flag = True
        if is_prime(abs(b)):
            for a in range(-a_max, a_max + 1):
                if flag:
                    for n in range(100):
                        x = n ** 2 + a * n + b
                        if is_prime(abs(x)):
                            continue
                        else:
                            if res[0] < n:
                                res = [n, [a, b]]

                            break
    return res[1][0] * res[1][1]


# print(problem_27())

"""
Задача 28
Начиная с числа 1 и двигаясь дальше вправо по часовой стрелке, образуется следующая спираль 5 на 5:
21 22 23 24 25
20  7  8  9 10
19  6  1  2 11
18  5  4  3 12
17 16 15 14 13
Можно убедиться, что сумма чисел в диагоналях равна 101.
Какова сумма чисел в диагоналях спирали 1001 на 1001, образованной таким же способом?
"""


@timer
def problem_28(n=1001):
    res = 1
    for i in range(3, n + 1, 2):
        res += i ** 2 + (i ** 2 - (i - 1) * 1) + (i ** 2 - (i - 1) * 2) + (i ** 2 - (i - 1) * 3)

    return res


# print(problem_28())


"""
Задача 29
Рассмотрим все целочисленные комбинации ab для 2 ≤ a ≤ 5 и 2 ≤ b ≤ 5:
2^2=4, 2^3=8, 2^4=16, 2^5=32
3^2=9, 3^3=27, 3^4=81, 3^5=243
4^2=16, 4^3=64, 4^4=256, 4^5=1024
5^2=25, 5^3=125, 5^4=625, 5^5=3125
Если их расположить в порядке возрастания, исключив повторения, мы получим
 следующую последовательность из 15 различных членов:
4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
Сколько различных членов имеет последовательность ab для 2 ≤ a ≤ 100 и 2 ≤ b ≤ 100?
"""


@timer
def problem_29(a=100, b=100):
    res = set()
    for i in range(2, a + 1):
        for j in range(2, b + 1):
            res.add(i ** j)
    return len(res)


# print(problem_29())


"""
Задача 30
Удивительно, но существует только три числа, которые могут быть 
записаны в виде суммы четвертых степеней их цифр:
1634 = 14 + 64 + 34 + 44
8208 = 84 + 24 + 04 + 84
9474 = 94 + 44 + 74 + 44
1 = 14 не считается, так как это - не сумма.
Сумма этих чисел равна 1634 + 8208 + 9474 = 19316.
Найдите сумму всех чисел, которые могут быть записаны в виде суммы пятых степеней их цифр.
"""


@timer
def problem_30(power=5):
    res = []

    def max_len(power=power):
        n = 2
        while True:
            if len(str(n * (9 ** power))) < n:
                return n - 1
            else:
                n += 1

    for i in range(2, int("9" * max_len(power))):
        lst = [int(n) ** power for n in list(str(i))]
        if sum(lst) == i:
            res.append(i)

    return sum(res)


# print(problem_30())

"""
Задача 31
В Англии валютой являются фунты стерлингов £ и пенсы p, и в обращении есть восемь монет:
1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) и £2 (200p).
£2 возможно составить следующим образом:
1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p
Сколькими разными способами можно составить £2, используя любое количество монет?
"""


@timer
def problem_31(n=200):
    coins = [2, 5, 10, 20, 50, 100, 200]
    indexes = [-2, -3, -4, -5, -7, -8, -9]
    res = [[]]
    while sum(res[0]) < n:
        print(sum(res[0]))
        for lst in res:
            lst.append(1)
        new_lists = []
        for lst in res:
            for ind in indexes:
                if sum(lst[ind:]) == coins[indexes.index(ind)]:
                    new_lst = lst[:]
                    del new_lst[ind:]
                    new_lst.insert(ind, coins[indexes.index(ind)])
                    new_lists.append(sorted(new_lst, reverse=True))

        if new_lists:
            for lst in new_lists:
                if lst not in res:
                    res.append(lst)

    return len(res)


""" Решается около 10 минут, надо оптимизировать"""
# print(problem_31())


"""
Задача 32
Каждое n-значное число, которое содержит каждую цифру от 1 до n ровно один раз, будем считать 
пан-цифровым; к примеру, 5-значное число 15234 является пан-цифровым, т.к. содержит цифры от 1 до 5.
Произведение 7254 является необычным, поскольку равенство 39 × 186 = 7254, состоящее из множимого, 
множителя и произведения является пан-цифровым, т.е. содержит цифры от 1 до 9.
Найдите сумму всех пан-цифровых произведений, для которых равенство "множимое × множитель = произведение" 
можно записать цифрами от 1 до 9, используя каждую цифру только один раз.
ПОДСКАЗКА: Некоторые произведения можно получить несколькими способами, поэтому убедитесь, что включили 
их в сумму лишь единожды.
"""


@timer
def problem_32():
    res = set()
    for i in range(3000):
        for j in range(99):
            text_num = str(i * j) + str(j) + str(i)
            if len(text_num) == 9:
                if "0" not in text_num:
                    if len(set(list(text_num))) == 9:
                        print(i, j, i * j)
                        res.add(i * j)

    return sum(res)


# print(problem_32())


"""
Задача 33
Дробь 49/98 является любопытной, поскольку неопытный математик, пытаясь сократить ее, 
будет ошибочно полагать, что 49/98 = 4/8, являющееся истиной, получено вычеркиванием девяток.
Дроби вида 30/50 = 3/5 будем считать тривиальными примерами.
Существует ровно 4 нетривиальных примера дробей подобного типа, которые меньше единицы и содержат 
двухзначные числа как в числителе, так и в знаменателе.
Пусть произведение этих четырех дробей дано в виде несократимой дроби (числитель и знаменатель дроби 
не имеют общих сомножителей). Найдите знаменатель этой дроби.
"""


@timer
def problem_33():
    numbers = []
    for i in range(11, 99):
        for k in range(11, 99):
            if i < k:
                res = i / k
                x, y = str(i), str(k)
                if "0" not in x + y:
                    if ((int(x[0]) / int(y[0]) == res) and (int(x[1]) == int(y[1]))) or \
                            ((int(x[1]) / int(y[0]) == res) and (int(x[0]) == int(y[1]))) or \
                            ((int(x[0]) / int(y[1]) == res) and (int(x[1]) == int(y[0]))) or \
                            ((int(x[1]) / int(y[1]) == res) and (int(x[0]) == int(y[0]))):
                        numbers.append([i, k])
    num1, num2 = 1, 1
    for i in numbers:
        num1 *= i[0]
        num2 *= i[1]
    for i in divisors(num2)[::-1]:
        if (num1 % i == 0) and (num2 % i == 0):
            num1 = num1 / i
            num2 = num2 / i

    return num2


# print(problem_33())


"""
Задача 34
145 является любопытным числом, поскольку 1! + 4! + 5! = 1 + 24 + 120 = 145.
Найдите сумму всех чисел, каждое из которых равно сумме факториалов своих цифр.
Примечание: поскольку 1! = 1 и 2! = 2 не являются суммами, учитывать их не следует.
"""


@timer
def problem_34():
    res = 0
    # TODO почему такой лимит? Зная ответ можно вписать 41000 и решение будет за 0,5 с., а с этим лимитом 16 с.
    limit = 7 * factorial(9) + 1
    for i in range(3, limit):
        sum_factorials = sum([factorial(int(i)) for i in list(str(i))])
        if sum_factorials == i:
            print(i)
            res += i
    return res


# print(problem_34())


"""
Задача 25
Число 197 называется круговым простым числом, потому что все перестановки его цифр 
с конца в начало являются простыми числами: 197, 719 и 971.
Существует тринадцать таких простых чисел меньше 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79 и 97.
Сколько существует круговых простых чисел меньше миллиона?
"""


def check_variations_is_prime(n: str):
    if len(n) == 1:
        return True
    if any(num in ["0", "2", "4", "6", "8"] for num in n):
        return False
    for i in range(len(n)):
        n = n[1:] + n[0]
        if not is_prime(int(n)):
            return False
    return True


@timer
def problem_35(n=1000000):
    res = 0
    for i in range(2, n):
        if is_prime(i):
            if check_variations_is_prime(str(i)):
                res += 1
    return res


# print(problem_35())


"""
Задача 36
Десятичное число 585 = 10010010012 (в двоичной системе), является палиндромом по обоим основаниям.
Найдите сумму всех чисел меньше миллиона, являющихся палиндромами по основаниям 10 и 2.
(Пожалуйста, обратите внимание на то, что палиндромы не могут начинаться с нуля ни в одном из оснований).
"""


def is_palindrome(n: str):
    if n == n[::-1]:
        return True


@timer
def problem_36(n=1000000):
    res = 0
    for i in range(1, n, 2):
        if all([is_palindrome(str(i)), is_palindrome(bin(i)[2:])]):
            res += i

    return res


# print(problem_36())


"""
Задача 37
Число 3797 обладает интересным свойством. Будучи само по себе простым числом, 
из него можно последовательно выбрасывать цифры слева направо, число же при этом 
остается простым на каждом этапе: 3797, 797, 97, 7. Точно таким же способом можно 
выбрасывать цифры справа налево: 3797, 379, 37, 3.
Найдите сумму единственных одиннадцати простых чисел, из которых можно выбрасывать 
цифры как справа налево, так и слева направо, но числа при этом остаются простыми.
ПРИМЕЧАНИЕ: числа 2, 3, 5 и 7 таковыми не считаются.
"""


def check_variations_is_prime_2(n: str):
    if len(n) == 1:
        return False
    if n.endswith("1") or n.startswith("1"):
        return False
    if any(num in ["0", "4", "6", "8"] for num in n):
        return False
    for i in range(len(n) - 1):
        n1 = n[i + 1:]
        n2 = n[:-i - 1]
        if not is_prime(int(n1)):
            return False
        if not is_prime(int(n2)):
            return False
    return True


@timer
def problem_37(n=1000000):
    res = 0
    for i in range(11, n, 2):
        if is_prime(i):
            if check_variations_is_prime_2(str(i)):
                res += i
    return res


# print(problem_37())


"""
Задача 38
Возьмем число 192 и умножим его по очереди на 1, 2 и 3:
192 × 1 = 192
192 × 2 = 384
192 × 3 = 576
Объединяя все три произведения, получим девятизначное число 192384576 из цифр 
от 1 до 9 (пан-цифровое число). Будем называть число 192384576 объединенным произведением 192 и (1,2,3)
Таким же образом можно начать с числа 9 и по очереди умножать его на 1, 2, 3, 4 и 5, 
что в итоге дает пан-цифровое число 918273645, являющееся объединенным произведением 9 и (1,2,3,4,5).
Какое самое большое девятизначное пан-цифровое число можно образовать как объединенное 
произведение целого числа и (1,2, ... , n), где n > 1?
"""


@timer
def problem_38():
    res = []
    for i in range(10000):
        text_num = ""
        for k in range(1, 10):
            text_num += str(k * i)
            if len(text_num) == 9:
                if "0" not in text_num:
                    if len(set(list(text_num))) == 9:
                        res.append(int(text_num))
                else:
                    break
    return max(res)


# print(problem_38())


"""
Задача 39
Если p - периметр прямоугольного треугольника с целочисленными длинами 
сторон {a,b,c}, то существует ровно три решения для p = 120:
{20,48,52}, {24,45,51}, {30,40,50}
Какое значение p ≤ 1000 дает максимальное число решений?
"""


@timer
def problem_39(n=1000):
    res = []
    for a in range(1, n):
        for b in range(1, n):
            c = (a ** 2 + b ** 2) ** 0.5
            if c % 1 == 0:
                res.append(a + b + c)
    max_count = [0, 0]
    for i in res:
        if i <= n:
            count = res.count(i)
            if count > max_count[0]:
                max_count[0] = count
                max_count[1] = i

    return max_count


# print(problem_39())

"""
Задача 40
Дана иррациональная десятичная дробь, образованная объединением натуральных чисел:
0.123456789101112131415161718192021...
Видно, что 12-я цифра дробной части - 1.
Также дано, что dn представляет собой n-ю цифру дробной части. Найдите значение следующего выражения:
d1 × d10 × d100 × d1000 × d10000 × d100000 × d1000000
"""


@timer
def problem_40():
    a = ""
    for i in range(400000):  # Можно до 1е6, но так чуть быстрее.
        a += str(i)
    return (int(a[1]) * int(a[10]) * int(a[100]) * int(a[1000])
            * int(a[10000]) * int(a[100000]) * int(a[1000000]))


# print(problem_40())


"""
Задача 41
Будем считать n-значное число пан-цифровым, если каждая из цифр от 1 
до nиспользуется в нем ровно один раз. К примеру, 2143 является 4-значным 
пан-цифровым числом, а также простым числом.
Какое существует наибольшее n-значное пан-цифровое простое число?
"""


@timer
def problem_41(n=7):
    for i in range(7777777, 1234567, -1):
        if i % 2 != 0:
            str_num = str(i)
            if ("0" not in str_num) and ("9" not in str_num) and ("8" not in str_num):
                if len(set(list(str_num))) == n:
                    if is_prime(i):
                        return i


""" Все пан-цифровые числа делятся на 3 кроме n=7,4,1. Поэтому проверяем 7 циферные."""

# print(problem_41())


"""
Задача 42
n-й член последовательности треугольных чисел задается как tn = ½n(n+1). 
Таким образом, первые десять треугольных чисел:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
Преобразовывая каждую букву в число, соответствующее ее порядковому номеру в 
алфавите, и складывая эти значения, мы получим числовое значение слова. 
Для примера, числовое значение слова SKY равно 19 + 11 + 25 = 55 = t10. 
Если числовое значение слова является треугольным числом, то мы назовем это слово треугольным словом.
Используя words.txt (щелкнуть правой кнопкой мыши и выбрать 
'Save Link/Target As...'), 16 КБ текстовый файл, содержащий около двух тысяч 
часто используемых английских слов, определите, сколько в нем треугольных слов.
"""


def get_num_char(x: str) -> int:
    if len(x) == 1:
        return ord(x) - 64
    else:
        raise ValueError("Передано больше одного символа")


def get_list_names_from_file(file: str) -> list:
    with open(file) as file:
        text = file.read().replace('"', "").split(",")
    return text


@timer
def problem_42():
    triangle_numbers = [int((n * (n + 1)) / 2) for n in list(range(1, 100))]
    words = get_list_names_from_file("files/p042_words.txt")
    res = 0
    for word in words:
        sum_chars = 0
        for char in word:
            sum_chars += get_num_char(char)
        if sum_chars in triangle_numbers:
            res += 1
    return res

# print(problem_42())


"""
Задача 43
Число 1406357289, является пан-цифровым, поскольку оно состоит из цифр от 0 до 9 
в определенном порядке. Помимо этого, оно также обладает интересным свойством делимости подстрок.
Пусть d1 будет 1-й цифрой, d2 будет 2-й цифрой, и т.д. В таком случае, можно заметить следующее:
d2d3d4=406 делится на 2 без остатка
d3d4d5=063 делится на 3 без остатка
d4d5d6=635 делится на 5 без остатка
d5d6d7=357 делится на 7 без остатка
d6d7d8=572 делится на 11 без остатка
d7d8d9=728 делится на 13 без остатка
d8d9d10=289 делится на 17 без остатка
Найдите сумму всех пан-цифровых чисел из цифр от 0 до 9, обладающих данным свойством.
"""

# Зачем изобретать велосипед?
def permutations(iterable, r=None):
    # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC
    # permutations(range(3)) --> 012 021 102 120 201 210
    pool = tuple(iterable)
    n = len(pool)
    r = n if r is None else r
    if r > n:
        return
    indices = list(range(n))
    cycles = list(range(n, n-r, -1))
    yield tuple(pool[i] for i in indices[:r])
    while n:
        for i in reversed(range(r)):
            cycles[i] -= 1
            if cycles[i] == 0:
                indices[i:] = indices[i+1:] + indices[i:i+1]
                cycles[i] = n - i
            else:
                j = cycles[i]
                indices[i], indices[-j] = indices[-j], indices[i]
                yield tuple(pool[i] for i in indices[:r])
                break
        else:
            return


@timer
def problem_43():
    res = 0
    n = permutations("9876543210")
    for i in n:
        if int(i[3]) % 2 != 0:
            continue
        if int(i[2] + i[3] + i[4]) % 3 != 0:
            continue
        j = "".join(i)
        if int(j[1] + j[2] + j[3]) % 2 == 0 and \
            int(j[2] + j[3] + j[4]) % 3 == 0 and \
            int(j[3] + j[4] + j[5]) % 5 == 0 and \
            int(j[4] + j[5] + j[6]) % 7 == 0 and \
            int(j[5] + j[6] + j[7]) % 11 == 0 and \
            int(j[6] + j[7] + j[8]) % 13 == 0 and \
            int(j[7] + j[8] + j[9]) % 17 == 0:
            res += int(j)
            print(j)
    return res


# print(problem_43())


"""
Задача 44
Пятиугольные числа вычисляются по формуле: Pn=n(3n−1)/2. 
Первые десять пятиугольных чисел:
1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
Можно убедиться в том, что P4 + P7 = 22 + 70 = 92 = P8. 
Однако, их разность, 70 − 22 = 48, не является пятиугольным числом.
Найдите пару пятиугольных чисел Pj и Pk, для которых сумма и разность 
являются пятиугольными числами и значение D = |Pk − Pj| минимально, и дайте значение D в качестве ответа.
"""


@timer
def problem_44():
    res = 999999999
    lst = set([int(n * (3*n - 1) / 2) for n in range(1, 5000)])
    per_lst = permutations(lst, r=2)
    for i in per_lst:
        if (i[0] + i[1]) in lst and abs(i[0] - i[1]) in lst:
            d = abs(i[0] - i[1])
            if d < res:
                res = d
    return res

# print(problem_44())


"""
Задача 45
Треугольные, пятиугольные и шестиугольные числа вычисляются по нижеследующим формулам:
Треугольные	 	    Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Пятиугольные	 	Pn=n(3n−1)/2	1, 5, 12, 22, 35, ...
Шестиугольные	 	Hn=n(2n−1)	 	1, 6, 15, 28, 45, ...
Можно убедиться в том, что T285 = P165 = H143 = 40755.
Найдите следующее треугольное число, являющееся также пятиугольным и шестиугольным.
"""

@timer
def problem_45():
    triangle_nums = set([n*(n+1)/2 for n in range(2, 100000)])
    fivangle_nums = set([n*(3*n-1)/2 for n in range(2, 100000)])
    sixangle_nums = set([n*(2*n-1) for n in range(2, 100000)])
    for i in triangle_nums:
        if i in fivangle_nums and i in sixangle_nums:
            res = i
    return res

# print(problem_45())


"""
Задача 46
Кристиан Гольдбах показал, что любое нечетное составное число можно 
записать в виде суммы простого числа и удвоенного квадрата.
9 = 7 + 2×1^2
15 = 7 + 2×2^2
21 = 3 + 2×3^2
25 = 7 + 2×3^2
27 = 19 + 2×2^2
33 = 31 + 2×1^2
Оказалось, что данная гипотеза неверна.
Каково наименьшее нечетное составное число, которое нельзя записать в виде суммы 
простого числа и удвоенного квадрата?
"""

@timer
def problem_46(n=10000):
    res = set()
    nums = set([n for n in range(2, n) if not (is_prime(n)) and (n % 2 != 0)])
    prime_numbers = set([n for n in range(2, n) if is_prime(n)])
    double_squares = [2*n**2 for n in range(1, int(n**0.5))]
    for i in range(4, n):
        if i in prime_numbers or i % 2 == 0:
            continue
        for d_s in double_squares:
            if d_s >= i:
                break
            if i - d_s in prime_numbers:
                res.add(i)
                break
    result = []
    for i in nums:
        if i not in res:
            result.append(i)
    return min(result)


# print(problem_46())


"""
Задача 47
Первые два последовательные числа, каждое из которых имеет два отличных друг 
от друга простых множителя:
14 = 2 × 7
15 = 3 × 5
Первые три последовательные числа, каждое из которых имеет три отличных друг 
от друга простых множителя:
644 = 2² × 7 × 23
645 = 3 × 5 × 43
646 = 2 × 17 × 19.
Найдите первые четыре последовательных числа, каждое из которых имеет четыре 
отличных друг от друга простых множителя. Каким будет первое число?
"""
@timer
def problem_47(n=4):
    stack = 0
    for i in range(1, 140000):
        divs = divisors(i)
        divs = [n for n in divs if is_prime(n) and n != 1]
        if len(divs) >= n:
            stack += 1
        else:
            stack = 0
        if stack == n:
            print(i-3)


# print(problem_47())


"""
Задача 48
Сумма 1^1 + 2^2 + 3^3 + ... + 10^10 = 10405071317.
Найдите последние десять цифр суммы 1^1 + 2^2 + 3^3 + ... + 1000^1000.
"""

@timer
def problem_48(n=1000):
    res = 0
    for i in range(1, n+1):
        res += i**i
    return str(res)[-10:]

# print(problem_48())


"""
Задача 49
Арифметическая прогрессия: 1487, 4817, 8147, в которой каждый член возрастает 
на 3330, необычна в двух отношениях: (1) каждый из трех членов является простым числом,
(2) все три четырехзначные числа являются перестановками друг друга.
Не существует арифметических прогрессий из трех однозначных, двухзначных и 
трехзначных простых чисел, демонстрирующих это свойство. Однако, существует 
еще одна четырехзначная возрастающая арифметическая прогрессия.
Какое 12-значное число образуется, если объединить три члена этой прогрессии?
"""

@timer
def problem_49():
    for i in range(1000, 9999):
        if is_prime(i) and i != 1487:
            if is_prime(i+3330) and is_prime(i+2*3330):
                if set(list(str(i))) == set(list(str(i+3330))) and set(list(str(i))) == set(list(str(i + 2*3330))):
                    return str(i) + str(i+3330) + str(i+2*3330)

# print(problem_49())


"""
Задача 50
Простое число 41 можно записать в виде суммы шести последовательных простых чисел:
41 = 2 + 3 + 5 + 7 + 11 + 13
Это - самая длинная сумма последовательных простых чисел, в результате которой
получается простое число меньше одной сотни.
Самая длинная сумма последовательных простых чисел, в результате которой получается
простое число меньше одной тысячи, содержит 21 слагаемое и равна 953.
Какое из простых чисел меньше одного миллиона можно записать в виде суммы 
наибольшего количества последовательных простых чисел?
"""

@timer
def problem_50(n=1000000):
    stack = 0
    res = [0, 0]
    lst = [n for n in range(2, int(n/250)) if is_prime(n)]
    for i in range(len(lst)):
        for k in range(20, 999):
            if i + k >= len(lst):
                break
            if is_prime(sum(lst[i:i+k])) and sum(lst[i:i+k]) <= n:
                stack = k
            else:
                if res[0] < stack:
                    res[0] = stack
                    res[1] = sum(lst[i:i+k-1])
    return res

print(problem_50())


