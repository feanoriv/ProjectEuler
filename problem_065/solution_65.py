from my_tools.tools import timer


"""
Квадратный корень из 2 можно записать в виде бесконечной непрерывной дроби.
Бесконечную непрерывную дробь можно записать, воспользовавшись обозначением √2 = [1;(2)], 
где (2) указывает на то, что 2 повторяется до бесконечности. Подобным образом, √23 = [4;(1,3,1,8)].
Оказывается, что последовательность частичных значений непрерывных дробей предоставляет 
наилучшую рациональную аппроксимацию квадратного корня. Рассмотрим приближения √2.
Таким образом, последовательность первых десяти приближений для √2 имеет вид:
1, 3/2, 7/5, 17/12, 41/29, 99/70, 239/169, 577/408, 1393/985, 3363/2378, ...
Самое удивительное, что важная математическая константа
e = [2; 1,2,1, 1,4,1, 1,6,1 , ... , 1,2k,1, ...].
Первые десять членов последовательности приближений для e перечислены ниже:
2, 3, 8/3, 11/4, 19/7, 87/32, 106/39, 193/71, 1264/465, 1457/536, ...
Сумма цифр числителя 10-го приближения равна 1 + 4 + 5 + 7 = 17.
Найдите сумму цифр числителя 100-го приближения непрерывной дроби для e.
"""

# Алгоритм обратного преобразования:
# // f[] - массив коэффициентов цепной дроби с индексами 0...k-1
# // k - количество коэффициентов
# n ⟵ f[k-1];
# d ⟵ 1;
# loop while k greater than 1
#         r ⟵  d;
#         d ⟵ n;
#         k ⟵ k-1;
#         n ⟵ f[k-1]*n+r;
# end loop
# output ⟵ n/d;


@timer
def problem_65(n=99):
    lst = [1]*n
    k = 1
    for i, elem in enumerate(lst):  # Список коэффициентов цепной(непрерывной) дроби
        if (i - 1) % 3 == 0:
            lst[i] = 2 * k
            k += 1

    # Алгоритм обратного преобразования:
    k = len(lst)
    p = lst[k-1]  # Знаменатель
    d = 1  # Числитель
    while k > 1:
        r = d
        d = p
        k -= 1
        p = lst[k-1] * p + r
    return sum([int(x) for x in str(p * 2 + d)])


if __name__ == "__main__":
    print(problem_65())
