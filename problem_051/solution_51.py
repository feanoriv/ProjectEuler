from my_tools.tools import timer, is_prime
"""
Задача 51
Меняя первую цифру числа *3 (двузначного числа, заканчивающегося цифрой 3), 
оказывается, что шесть из девяти возможных значений - 13, 23, 43, 53, 73 и 83 - 
являются простыми числами.
При замене третьей и четвертой цифры числа 56**3 одинаковыми цифрами, получаются 
десять чисел, из которых семь - простые: 56003, 56113, 56333, 56443, 56663, 56773 и 56993. 
Число 56**3 является наименьшим числом, подставление цифр в которое дает именно семь 
простых чисел. Соответственно, число 56003, будучи первым из полученных простых чисел, 
является наименьшим простым числом, обладающим указанным свойством.
Найдите наименьшее простое число, которое является одним из восьми простых чисел, 
полученных заменой части цифр (не обязательно соседних) одинаковыми цифрами.
"""


# Хоть тут и не сказано о количестве 'части цифр', минимальное число цифр - 3.
# Вот почему. Если сумма цифр числа кратна трём, то и само число кратно 3, не является простым.
# Следовательно, если мы последовательно будем прибавлять к любому числу, которое является суммой цифр,
# единицу (550-551-552-553-554-555..) , то сумма цифр числа будет кратна трём минимум 3 раза(552-555-558)
# (только 7 оставшихся цифр подойдут по условию).
# Так же происходит и с заменой двух (00-11-22-33-44) (цифры должны быть одинаковые).
# А вот изменяя 3 одинаковых цифры в числе другими тремя цифрами мы не получим сумму цифр числа кратной 3,
# если изначально оно не было кратно 3.
# Это сильно сужает перечень подходящих простых чисел, т.к. в нём должны изначально повторяться как минимум 3 цифры.

# Для подсчёта повторяющихся символов можно использовать Counters из модуля collections,
# но можно сделать и свой велосипед.

@timer
def problem_51(n=8):
    def is_meet_number(num: int) -> bool:  # Есть ли в числе 3+ повторяющиеся цифры
        num = str(num)
        if len(num) - len(set(num)) < 3:
            return False
        for char in set(num):
            if list(num).count(char) >= 3:
                return True
        return False

    def get_list_numbers(num):  # Возвращает список всех чисел с перестановками
        num = str(num)
        res_list = []
        nums = [str(i) for i in range(10)]

        for char in set(num):
            if list(num).count(char) >= 3:
                for k in nums:
                    res_list.append(int(num.replace(char, k)))
                return set(res_list)

    primes = {i for i in range(2, 1000000) if is_prime(i) and is_meet_number(i)}
    for prime in primes:
        if len(primes.intersection(get_list_numbers(prime))) >= n:
            return min(primes.intersection(get_list_numbers(prime)))


if __name__ == "__main__":
    print(problem_51())
